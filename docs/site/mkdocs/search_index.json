{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to RingaJS\n\n\nWhat is it\n\n\nRingaJS is a single page application framework that includes:\n\n\n\n\nMVC / MVVM hybrid\n structure with little boilerplate\n\n\nState management\n with no singletons\n\n\nPerformance centered \nobserver pattern\n\n\nDependency injection\n\n\nAsynchronous toolset\n with branching, looping, and error handling\n\n\n\n\nIt is hard to explain what Ringa is in a single sentence because it just does so much. This was built in my spare time the last year as a way to shift all the most difficult\nconcepts to rapid application development into a core set of Classes to improve my own development speed. It was also designed as a way to organize large enterprise\napplications in a way that made it extremely easy to monitor large teams as they work in a growing codebase.\n\n\nRinga's philosophy can be summed up with a few mantras:\n\n\n\n\nShield new developers from concepts they do not need to know... yet\n\n\nLet seasoned developers configure or extend anything\n\n\nGive everyone easy to understand error messages and warnings\n\n\nNever sacrifice performance\n\n\nNo fancy string parsing for observers\n\n\nGive developers 100% control over their observables\n\n\n\n\nLatest Version\n\n\nThe latest version is \n0.1.0\n Alpha.\n\n\nRingaJS is currently in Alpha version and has been so since Janary 2017, and while being used live, has not been battle-tested on a large scale quite yet. We would\nlove your input and your bug reports.\n\n\nRequirements\n\n\nRight now RingaJS is being developed for an ES6+ development environment and has been tested on:\n\n\n\n\nChrome\n\n\nFirefox\n\n\nSafari\n\n\nIE 11+\n\n\n\n\nInstallation\n\n\n\n\nnpm install --save-dev ringa\n - Install Ringa into your project\n\n\n\n\nTesting\n\n\nRinga currently has around 200 unit tests to ensure its core features are running smoothly. Test can be run with:\n\n\nnpm run test\n\n\nMy personal goal is 100% coverage so there is a little work to do! Results as of Oct. 9th, 2017 are:\n\n\n\n\nLicense\n\n\nMIT", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-ringajs", 
            "text": "", 
            "title": "Welcome to RingaJS"
        }, 
        {
            "location": "/#what-is-it", 
            "text": "RingaJS is a single page application framework that includes:   MVC / MVVM hybrid  structure with little boilerplate  State management  with no singletons  Performance centered  observer pattern  Dependency injection  Asynchronous toolset  with branching, looping, and error handling   It is hard to explain what Ringa is in a single sentence because it just does so much. This was built in my spare time the last year as a way to shift all the most difficult\nconcepts to rapid application development into a core set of Classes to improve my own development speed. It was also designed as a way to organize large enterprise\napplications in a way that made it extremely easy to monitor large teams as they work in a growing codebase.  Ringa's philosophy can be summed up with a few mantras:   Shield new developers from concepts they do not need to know... yet  Let seasoned developers configure or extend anything  Give everyone easy to understand error messages and warnings  Never sacrifice performance  No fancy string parsing for observers  Give developers 100% control over their observables", 
            "title": "What is it"
        }, 
        {
            "location": "/#latest-version", 
            "text": "The latest version is  0.1.0  Alpha.  RingaJS is currently in Alpha version and has been so since Janary 2017, and while being used live, has not been battle-tested on a large scale quite yet. We would\nlove your input and your bug reports.", 
            "title": "Latest Version"
        }, 
        {
            "location": "/#requirements", 
            "text": "Right now RingaJS is being developed for an ES6+ development environment and has been tested on:   Chrome  Firefox  Safari  IE 11+", 
            "title": "Requirements"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install --save-dev ringa  - Install Ringa into your project", 
            "title": "Installation"
        }, 
        {
            "location": "/#testing", 
            "text": "Ringa currently has around 200 unit tests to ensure its core features are running smoothly. Test can be run with:  npm run test  My personal goal is 100% coverage so there is a little work to do! Results as of Oct. 9th, 2017 are:", 
            "title": "Testing"
        }, 
        {
            "location": "/#license", 
            "text": "MIT", 
            "title": "License"
        }, 
        {
            "location": "/whyRinga/", 
            "text": "When designing Ringa we asked the following questions:\n\n\n\n\nWhat is the development problem?\n\n\nWhat would be the most enjoyable code to write to solve it?\n\n\nIs this going to scale and not impact the \ncomputers performance\n?\n\n\nIs this going to scale and not impact the \nnext developers performance\n?\n\n\n\n\nWe went back to the drawing board and put on our computer scientist caps to solve each problem and answer each of the 4 Questions. As a result, to understand why Ringa is so powerful a basic understanding of trees, graphs, algorithms, and software design patterns like singletons, factories, decorators, and dependency injection is a huge plus.\n\n\nAdvantages\n\n\nRinga provides the following high-level architectural advantages:\n\n\n\n\nUses DOM event system\n\n\nControllers are attached to a DOM node so there are no God objects\n\n\nUse 'bubble' and 'capture' to communicate between controllers through the DOM\n\n\nIntercept events at a higher level in the DOM so that the root of your application always has complete control\n\n\nAll RingaEvents include information on the view that dispatched them, the line of code they were dispatched from, the controller that is handling them, the commands that are responding, and much, much more\n\n\nFollows the Best MVC principles\n\n\nControllers are designed to keep your view, API, control, and model separated\n\n\nAsynchronous Syntax\n\n\nWriting complicated trees of asynchronous and synchronous processes is simple\n\n\nReading someone else's complex tree of asynchronous tasks is straightforward\n\n\nExtending, intercepting, or injecting into an existing asynchronous process is easy, but never interferes with debugging so there are no surprises\n\n\nDebugging when something fails in a complex tree of asynchronous tasks is at your fingertips\n\n\n\n\nDeveloping with Ringa\n\n\nRinga is designed for enterprise-level applications and scales with your team to keep everyone happy. It is designed with the idea that you will eventually have a large application with a lot of library dependencies and also so that your code can be cordoned off into discrete sections so that there is less developer conflict during development.", 
            "title": "Why Ringa"
        }, 
        {
            "location": "/whyRinga/#advantages", 
            "text": "Ringa provides the following high-level architectural advantages:   Uses DOM event system  Controllers are attached to a DOM node so there are no God objects  Use 'bubble' and 'capture' to communicate between controllers through the DOM  Intercept events at a higher level in the DOM so that the root of your application always has complete control  All RingaEvents include information on the view that dispatched them, the line of code they were dispatched from, the controller that is handling them, the commands that are responding, and much, much more  Follows the Best MVC principles  Controllers are designed to keep your view, API, control, and model separated  Asynchronous Syntax  Writing complicated trees of asynchronous and synchronous processes is simple  Reading someone else's complex tree of asynchronous tasks is straightforward  Extending, intercepting, or injecting into an existing asynchronous process is easy, but never interferes with debugging so there are no surprises  Debugging when something fails in a complex tree of asynchronous tasks is at your fingertips", 
            "title": "Advantages"
        }, 
        {
            "location": "/whyRinga/#developing-with-ringa", 
            "text": "Ringa is designed for enterprise-level applications and scales with your team to keep everyone happy. It is designed with the idea that you will eventually have a large application with a lot of library dependencies and also so that your code can be cordoned off into discrete sections so that there is less developer conflict during development.", 
            "title": "Developing with Ringa"
        }, 
        {
            "location": "/demo/", 
            "text": "Demo\n\n\nA full demo of the majority of Ringa's features can be found \nhere\n.\n\n\nSource Code (Web)\n\n\nSource Code (Server)", 
            "title": "Demo"
        }, 
        {
            "location": "/demo/#demo", 
            "text": "A full demo of the majority of Ringa's features can be found  here .  Source Code (Web)  Source Code (Server)", 
            "title": "Demo"
        }, 
        {
            "location": "/helloWorld/", 
            "text": "'Hello World' in Ringa\n\n\nIn this walkthrough we will guide you to building your first \nHello world\n application in Ringa using React and the \nreact-ringa\n plugin.", 
            "title": "Hello World"
        }, 
        {
            "location": "/helloWorld/#hello-world-in-ringa", 
            "text": "In this walkthrough we will guide you to building your first  Hello world  application in Ringa using React and the  react-ringa  plugin.", 
            "title": "'Hello World' in Ringa"
        }, 
        {
            "location": "/model/", 
            "text": "Model\n\n\n\n\nExtends \nBus\n\n\n\n\nExtends \nRingaObject\n\n\nimport {Model} from 'ringa';\n\n\n\n\n\n\nThe Ringa \nModel\n class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:\n\n\nIt provides:\n\n\n\n\nProperty management\n\n\nProperty watching\n\n\nBuilt in tree structure (optional)\n\n\nCloning (recursive)\n\n\nSerialization / deserialization (recursive)\n\n\nTrie-based indexing for search (recursive)\n\n\n\n\nExample \nUserModel\n\n\nThe following model will be used as an example throughout this document:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}\n\n\n\nIn this example, the \nUserModel\n is configured with three properties that by default:\n\n\n\n\nCan be watched for changes\n\n\nWill be included when serializing / deserializing\n\n\nWill be cloned if \nclone()\n is called\n\n\n\n\n1. Basics\n\n\nModel(name, values)\n\n\n\nThe Ringa \nModel\n constructor takes in an optional \nname\n string and optional \nvalues\n object. If the first property is an \nObject\n then it is assumed to be the \nvalues\n object.\n\n\nEvery new Ringa \nModel\n instance has the following base properties:\n\n\n\n\nid\n: inherited from \nRingaObject\n, a unique identifier for this model. A console warning will be issued if two \nRingaObjects\n contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default \nid\n is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.\n\n\nname\n: a human-readable name for the model. It is assumed that more than one model may have the same name. By default the \nname\n property is the Model class Constructor name in camelcase.\n\n\n_values\n: passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the \n_values\n property, not \nvalues\n since they are to be treated as protected members.\n\n\n\n\nUsing the example \nUserModel\n class above we could do the following:\n\n\nlet userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);\n\n\n\nOutput:\n\n\nid: UserModel1\nname: userModel\n_values: undefined\n\n\n\nThe only way to set the \nid\n property through the constructor is to use the \nvalues\n argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:\n\n\nlet userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);\n\n\n\nOutput:\n\n\nid: someCustomId\n_values: {id: 'someCustomId'}\n\n\n\nIf you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the \nvalues\n object as well:\n\n\nlet me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});\n\n\n\n1.1. Model Properties\n\n\nYou add properties to a Model with the \naddProperty\n method:\n\n\naddProperty(name, defaultValue, options);\n\n\n\n\n\nname\n: the name of the property.\n\n\ndefaultValue\n: the default value of the property.\n\n\noptions\n: a variety of options on how the property works. Discussed in the following sections.\n\n\n\n\n1.1.1. Model Property Name\n\n\naddProperty\n automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);\n\n\n\nOutput:\n\n\nto be or not to be\n\n\n\nNode: a future version of Ringa should attach the getter / setter for properties to the internal \nprototype\n for performance if possible.\n\n\n1.1.2. Model Property Defaults\n\n\nYou can specify default values for \nModel\n properties easily:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}\n\n\n\nAll properties in the \nModel\n default to \nundefined\n. In this case, we are saying the altitude should start, as it should, at \n0\n.\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.altitude);\n\n\n\nOutput:\n\n\n0\n\n\n\n1.1.3. Model Property Options (\npropertyOptions\n)\n\n\nThe third parameter to \naddProperty\n is an optional options \nObject\n:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}\n\n\n\nAll property options can be accessed through the \npropertyOptions\n dictionary:\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);\n\n\n\nOutput:\n\n\nThis is the altitude of the airplane.\n\n\n\nBe careful! If you accidentally pass the property options as the second parameter to \naddProperty\n they will be treated as the default value.\n\n\nNote: the following propertyOptions are reserved and used by Ringa:\n\n\n\n\ndescriptor\n\n\nsetParentModel\n\n\nautowatch\n\n\ndoNotNotify\n\n\nclone\n\n\ntype\n\n\nserialize\n\n\nget\n\n\nset\n\n\n\n\n1.1.4. Property Getters / Setters\n\n\nBy default, Ringa uses \nObject.defineProperty\n every time you call \naddProperty()\n to create a custom getter / setter on your model.\n\n\nHowever, you can override this quite easily:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =\n {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =\n {\n        return this._address;\n      }\n    });\n  }\n}\n\n\n\nNote: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!\n\n\n1.2. Watching / Observing Models\n\n\nModel's can be watched for property value changes or even custom signals.\n\n\nNote: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.\n\n\nUsing the Example Class \nUserModel\n defined at the beginning of this page, we could do the following:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';\n\n\n\nThe console will now output:\n\n\nA property has changed 'firstName': Saajan\n\n\n\n2. Advanced Features\n\n\nWhile all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.\n\n\n2.1. Cloning\n\n\nRinga \nModels\n can easily be cloned:\n\n\nlet userModel = new UserModel();\n\nlet clonee = userModel.clone();\n\n\n\nIn some cases you may not want to clone the \nid\n and instead want the cloned object to grab a new unique identifier:\n\n\nlet clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);\n\n\n\nOutput:\n\n\nUserModel2\n\n\n\nNote: in 2.3 we will explain how Ringa models can be structured like a tree. The \nclone()\n method is recursive on all descendants.\n\n\n2.2. Serialization\n\n\nEvery Ringa \nModel\n has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a \nModel\n tree (see section 2.3).\n\n\nBy default, only properties that have been added with \naddProperty\n are serialized or deserialized. \n\n\n2.2.1. Serializing\n\n\nTo serialize a Ringa \nModel\n:\n\n\nlet pojo = myModel.serialize();\n\n\n\nThere are lots of options for serializing Ringa models:\n\n\n\n\nOverride the \nserializeId\n getter on any \nModel\n to customize the \nid\n property for serialization.\n\n\nImplement the \nserializeProperties\n getter on any \nModel\n to return an Array of properties to be serialized for that \nModel\n.\n\n\n\n\nFor example:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());\n\n\n\nOutput\n\n\n{\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}\n\n\n\n2.2.2. Deserializing\n\n\nBasic deserialization is easy. Assuming the \nUserModel\n example used at the beginning of this page:\n\n\nlet pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});\n\n\n\nModel.deserialize\n will instantiate a new \nUserModel\n instance and populate each of its properties with values from the POJO (if they exist).\n\n\nFor simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.\n\n\nThis can be done in several ways:\n\n\n\n\nProvide a \ntype\n option for the root model\n\n\nSet \ntype\n on the property option (for properties)\n\n\nProvide a \nmodelMapper\n \nFunction\n to the deserialize options.\n\n\n\n\n2.2.2.1. Deserializing: \ntype\n option\n\n\nAs shown above, you can provide a \ntype\n property to the deserialize options:\n\n\nlet myModel = Model.deserialize(pojo, {\n  type: MyModel\n});\n\n\n\nNote that the type provided must extend \nModel\n.\n\n\n2.2.2.2. Deserializing: \ntype\n property option\n\n\nFor individual properties, you can specify the type when calling \naddProperty\n (including Arrays) and deserialization will instantiate a new \nModel\n of that type and deserialize into it:\n\n\nclass FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});\n\n\n\nIn this case, three instances of \nFamilyTreeNode\n will be constructed, and two of them will exist inside of the \nchildren\n property of the parent node.\n\n\n2.2.2.3. Deserializing: \nmodelMapper\n option\n\n\nIn some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.\n\n\nFor this situation, you can use the \nmodelMapper\n \nFunction\n option:\n\n\nclass TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =\n {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});\n\n\n\nIn this example, if \nsomePojo\n has a property named \ntext\n then the deserializer will make a new \nTextModel\n. If it has a property named \nnumber\n then the deserializer will\nmake a \nNumberModel\n.\n\n\nNote: the \nmodelMapper\n is passed recursively in the same options object to all descendants that are deserialized as well.\n\n\n2.3. Model Trees\n\n\nRinga Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.\n\n\nIn addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.\n\n\n2.3.1. Autowatching and linking child \nModels\n\n\nEvery \nModel\n object watches each property for changes and if a property is set to another \nModel\n object then an internal tree structure is automatically created:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);\n\n\n\nOutput:\n\n\nParent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}\n\n\n\nIn addition to watching their properties and linking to their child \nModels\n, every \nModel\n by default watches every single child \nModel\n for property changes and dispatches a dot-notation signal when any descendant has a change:\n\n\n...\nparent.watch(signal =\n console.log);\n\nchild.text = 'Hello World';\n\n\n\nOutput:\n\n\nchild.text\n\n\n\nThe purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.\n\n\nFor example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.\n\n\n2.3.2. Watching child \nModels\n in Arrays or Objects\n\n\nNote that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call \naddModelChild\n:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);\n\n\n\nThe first argument to \naddModelChild\n is the property that the parent can find that child within.\n\n\nThe reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.\n\n\n2.4. Notifications / \nnotify()\n\n\nBy default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.\n\n\nuser.watch(signal =\n console.log);\n\nuser.firstName = 'Josh');\n\n\n\nOutput:\n\n\nfirstName\n\n\n\nBut if the property does not change in value, then no signal is dispatched:\n\n\n// Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';\n\n\n\nThe handler method for a notification has the following signature:\n\n\nmyModel.watch((signal, signaler, value, descriptor) =\n {});\n\n\n\n\n\nsignal\n: the String signal (e.g. \n'firstName'\n). Will match the property name that has changed by default.\n\n\nsignaler\n: the \nModel\n that dispatched the signal. Useful in Model trees.\n\n\nvalue\n: the value of the property that changed (if associated with a property).\n\n\ndescriptor\n: a plain-text description of the signal (intended for use with a history feature).\n\n\n\n\n2.4.1. Custom Notifications\n\n\nOne cool feature of the Ringa \nModel\n is that you can notify your own custom signals:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');\n\n\n\n2.4.2. Turning off Notifications\n\n\nFor the sake of performance, you can turn off notifications by using the property option \ndoNotNotify\n:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');\n\n\n\nIn the above example, we notify a special event when either the \nfirstName\n or \nlastName\n has changed. This structure keeps the properties\n\nfirstName\n and \nlastName\n in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.\n\n\nAlso note that the property \nfullName\n - which may be useful in your view - is not included in the serialization / deserialization or cloning.\n\n\nThis is the standard way that I recommend implementing aggregate properties. \n\n\n2.5. Aggregate Properties\n\n\nA lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.\n\n\nUnfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:\n\n\n\n\nBindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.\n\n\nIncluding complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.\n\n\n\n\nMy goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.\n\n\n2.6. Watching property changes with \nonChange\n\n\nIf you want to do complex operations, you can do so like this:\n\n\nimport {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =\n {\n        this.notify('items');\n      }\n    });\n  }\n}\n\n\n\nNote: \nonChange\n only gets called if the value of the property \nfilter\n above actually changes to a new value.\n\n\nNow, when \nfilter\n changes, an \nitems\n signal will be dispatched:\n\n\nlet collection = new Collection();\n\ncollection.watch(signal =\n {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =\n value !== 2;\n\n\n\nOutput:\n\n\n1, 3\n\n\n\nThis notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.\n\n\n2.7 Indexing (Trie) and the \nindex\n option for search\n\n\nThe Ringa \nModel\n object allows you to index your models (recursively) using a fast-lookup \nTrie search\n. This is especially useful for type-ahead\nsearches:\n\n\nclass TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeplyl nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');\n\n\n\nIn this example, the call to \nindex()\n builds a new Trie internal to the root \ntree\n model. It indexes every single property that has been added with \nindex\n set to true.\n\n\nThe index method has the following signature:\n\n\nindex(recurse = false, trieSearchOptions = {}, trieSearch = undefined)\n\n\n\n\n\nrecurse\n: whether to recurse into child models and their indexed properties.\n\n\ntrieSearchOptions\n: these options will be passed into the Trie search. See the \ndocumentation\n for details.\n\n\ntrieSearch\n: if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.\n\n\n\n\nIndexing is not performed automatically, you must call \nindex()\n yourself. Also please do not call \nindex()\n more often than is necessary as building the indexing structure\nis time-intensive on large model trees.\n\n\n**Note: the \naddIndexedPropery()\n method can be used instead of \naddProperty(name, {index:true})\n.", 
            "title": "Model"
        }, 
        {
            "location": "/model/#model", 
            "text": "Extends  Bus   Extends  RingaObject  import {Model} from 'ringa';    The Ringa  Model  class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:  It provides:   Property management  Property watching  Built in tree structure (optional)  Cloning (recursive)  Serialization / deserialization (recursive)  Trie-based indexing for search (recursive)", 
            "title": "Model"
        }, 
        {
            "location": "/model/#example-usermodel", 
            "text": "The following model will be used as an example throughout this document:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}  In this example, the  UserModel  is configured with three properties that by default:   Can be watched for changes  Will be included when serializing / deserializing  Will be cloned if  clone()  is called", 
            "title": "Example UserModel"
        }, 
        {
            "location": "/model/#1-basics", 
            "text": "Model(name, values)  The Ringa  Model  constructor takes in an optional  name  string and optional  values  object. If the first property is an  Object  then it is assumed to be the  values  object.  Every new Ringa  Model  instance has the following base properties:   id : inherited from  RingaObject , a unique identifier for this model. A console warning will be issued if two  RingaObjects  contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default  id  is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.  name : a human-readable name for the model. It is assumed that more than one model may have the same name. By default the  name  property is the Model class Constructor name in camelcase.  _values : passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the  _values  property, not  values  since they are to be treated as protected members.   Using the example  UserModel  class above we could do the following:  let userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);  Output:  id: UserModel1\nname: userModel\n_values: undefined  The only way to set the  id  property through the constructor is to use the  values  argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:  let userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);  Output:  id: someCustomId\n_values: {id: 'someCustomId'}  If you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the  values  object as well:  let me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});", 
            "title": "1. Basics"
        }, 
        {
            "location": "/model/#11-model-properties", 
            "text": "You add properties to a Model with the  addProperty  method:  addProperty(name, defaultValue, options);   name : the name of the property.  defaultValue : the default value of the property.  options : a variety of options on how the property works. Discussed in the following sections.", 
            "title": "1.1. Model Properties"
        }, 
        {
            "location": "/model/#111-model-property-name", 
            "text": "addProperty  automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);  Output:  to be or not to be  Node: a future version of Ringa should attach the getter / setter for properties to the internal  prototype  for performance if possible.", 
            "title": "1.1.1. Model Property Name"
        }, 
        {
            "location": "/model/#112-model-property-defaults", 
            "text": "You can specify default values for  Model  properties easily:  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}  All properties in the  Model  default to  undefined . In this case, we are saying the altitude should start, as it should, at  0 .  let airplane = new Airplane();\n\nconsole.log(airplane.altitude);  Output:  0", 
            "title": "1.1.2. Model Property Defaults"
        }, 
        {
            "location": "/model/#113-model-property-options-propertyoptions", 
            "text": "The third parameter to  addProperty  is an optional options  Object :  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}  All property options can be accessed through the  propertyOptions  dictionary:  let airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);  Output:  This is the altitude of the airplane.  Be careful! If you accidentally pass the property options as the second parameter to  addProperty  they will be treated as the default value.  Note: the following propertyOptions are reserved and used by Ringa:   descriptor  setParentModel  autowatch  doNotNotify  clone  type  serialize  get  set", 
            "title": "1.1.3. Model Property Options (propertyOptions)"
        }, 
        {
            "location": "/model/#114-property-getters-setters", 
            "text": "By default, Ringa uses  Object.defineProperty  every time you call  addProperty()  to create a custom getter / setter on your model.  However, you can override this quite easily:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =  {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =  {\n        return this._address;\n      }\n    });\n  }\n}  Note: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!", 
            "title": "1.1.4. Property Getters / Setters"
        }, 
        {
            "location": "/model/#12-watching-observing-models", 
            "text": "Model's can be watched for property value changes or even custom signals.  Note: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.  Using the Example Class  UserModel  defined at the beginning of this page, we could do the following:  let user = new UserModel();\n\nuser.watch(signal =  {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';  The console will now output:  A property has changed 'firstName': Saajan", 
            "title": "1.2. Watching / Observing Models"
        }, 
        {
            "location": "/model/#2-advanced-features", 
            "text": "While all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.", 
            "title": "2. Advanced Features"
        }, 
        {
            "location": "/model/#21-cloning", 
            "text": "Ringa  Models  can easily be cloned:  let userModel = new UserModel();\n\nlet clonee = userModel.clone();  In some cases you may not want to clone the  id  and instead want the cloned object to grab a new unique identifier:  let clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);  Output:  UserModel2  Note: in 2.3 we will explain how Ringa models can be structured like a tree. The  clone()  method is recursive on all descendants.", 
            "title": "2.1. Cloning"
        }, 
        {
            "location": "/model/#22-serialization", 
            "text": "Every Ringa  Model  has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a  Model  tree (see section 2.3).  By default, only properties that have been added with  addProperty  are serialized or deserialized.", 
            "title": "2.2. Serialization"
        }, 
        {
            "location": "/model/#221-serializing", 
            "text": "To serialize a Ringa  Model :  let pojo = myModel.serialize();  There are lots of options for serializing Ringa models:   Override the  serializeId  getter on any  Model  to customize the  id  property for serialization.  Implement the  serializeProperties  getter on any  Model  to return an Array of properties to be serialized for that  Model .   For example:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());  Output  {\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}", 
            "title": "2.2.1. Serializing"
        }, 
        {
            "location": "/model/#222-deserializing", 
            "text": "Basic deserialization is easy. Assuming the  UserModel  example used at the beginning of this page:  let pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});  Model.deserialize  will instantiate a new  UserModel  instance and populate each of its properties with values from the POJO (if they exist).  For simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.  This can be done in several ways:   Provide a  type  option for the root model  Set  type  on the property option (for properties)  Provide a  modelMapper   Function  to the deserialize options.", 
            "title": "2.2.2. Deserializing"
        }, 
        {
            "location": "/model/#2221-deserializing-type-option", 
            "text": "As shown above, you can provide a  type  property to the deserialize options:  let myModel = Model.deserialize(pojo, {\n  type: MyModel\n});  Note that the type provided must extend  Model .", 
            "title": "2.2.2.1. Deserializing: type option"
        }, 
        {
            "location": "/model/#2222-deserializing-type-property-option", 
            "text": "For individual properties, you can specify the type when calling  addProperty  (including Arrays) and deserialization will instantiate a new  Model  of that type and deserialize into it:  class FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});  In this case, three instances of  FamilyTreeNode  will be constructed, and two of them will exist inside of the  children  property of the parent node.", 
            "title": "2.2.2.2. Deserializing: type property option"
        }, 
        {
            "location": "/model/#2223-deserializing-modelmapper-option", 
            "text": "In some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.  For this situation, you can use the  modelMapper   Function  option:  class TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =  {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});  In this example, if  somePojo  has a property named  text  then the deserializer will make a new  TextModel . If it has a property named  number  then the deserializer will\nmake a  NumberModel .  Note: the  modelMapper  is passed recursively in the same options object to all descendants that are deserialized as well.", 
            "title": "2.2.2.3. Deserializing: modelMapper option"
        }, 
        {
            "location": "/model/#23-model-trees", 
            "text": "Ringa Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.  In addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.", 
            "title": "2.3. Model Trees"
        }, 
        {
            "location": "/model/#231-autowatching-and-linking-child-models", 
            "text": "Every  Model  object watches each property for changes and if a property is set to another  Model  object then an internal tree structure is automatically created:  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);  Output:  Parent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}  In addition to watching their properties and linking to their child  Models , every  Model  by default watches every single child  Model  for property changes and dispatches a dot-notation signal when any descendant has a change:  ...\nparent.watch(signal =  console.log);\n\nchild.text = 'Hello World';  Output:  child.text  The purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.  For example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.", 
            "title": "2.3.1. Autowatching and linking child Models"
        }, 
        {
            "location": "/model/#232-watching-child-models-in-arrays-or-objects", 
            "text": "Note that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call  addModelChild :  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);  The first argument to  addModelChild  is the property that the parent can find that child within.  The reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.", 
            "title": "2.3.2. Watching child Models in Arrays or Objects"
        }, 
        {
            "location": "/model/#24-notifications-notify", 
            "text": "By default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.  user.watch(signal =  console.log);\n\nuser.firstName = 'Josh');  Output:  firstName  But if the property does not change in value, then no signal is dispatched:  // Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';  The handler method for a notification has the following signature:  myModel.watch((signal, signaler, value, descriptor) =  {});   signal : the String signal (e.g.  'firstName' ). Will match the property name that has changed by default.  signaler : the  Model  that dispatched the signal. Useful in Model trees.  value : the value of the property that changed (if associated with a property).  descriptor : a plain-text description of the signal (intended for use with a history feature).", 
            "title": "2.4. Notifications / notify()"
        }, 
        {
            "location": "/model/#241-custom-notifications", 
            "text": "One cool feature of the Ringa  Model  is that you can notify your own custom signals:  let user = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');", 
            "title": "2.4.1. Custom Notifications"
        }, 
        {
            "location": "/model/#242-turning-off-notifications", 
            "text": "For the sake of performance, you can turn off notifications by using the property option  doNotNotify :  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');  In the above example, we notify a special event when either the  firstName  or  lastName  has changed. This structure keeps the properties firstName  and  lastName  in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.  Also note that the property  fullName  - which may be useful in your view - is not included in the serialization / deserialization or cloning.  This is the standard way that I recommend implementing aggregate properties.", 
            "title": "2.4.2. Turning off Notifications"
        }, 
        {
            "location": "/model/#25-aggregate-properties", 
            "text": "A lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.  Unfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:   Bindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.  Including complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.   My goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.", 
            "title": "2.5. Aggregate Properties"
        }, 
        {
            "location": "/model/#26-watching-property-changes-with-onchange", 
            "text": "If you want to do complex operations, you can do so like this:  import {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =  {\n        this.notify('items');\n      }\n    });\n  }\n}  Note:  onChange  only gets called if the value of the property  filter  above actually changes to a new value.  Now, when  filter  changes, an  items  signal will be dispatched:  let collection = new Collection();\n\ncollection.watch(signal =  {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =  value !== 2;  Output:  1, 3  This notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.", 
            "title": "2.6. Watching property changes with onChange"
        }, 
        {
            "location": "/model/#27-indexing-trie-and-the-index-option-for-search", 
            "text": "The Ringa  Model  object allows you to index your models (recursively) using a fast-lookup  Trie search . This is especially useful for type-ahead\nsearches:  class TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeplyl nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');  In this example, the call to  index()  builds a new Trie internal to the root  tree  model. It indexes every single property that has been added with  index  set to true.  The index method has the following signature:  index(recurse = false, trieSearchOptions = {}, trieSearch = undefined)   recurse : whether to recurse into child models and their indexed properties.  trieSearchOptions : these options will be passed into the Trie search. See the  documentation  for details.  trieSearch : if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.   Indexing is not performed automatically, you must call  index()  yourself. Also please do not call  index()  more often than is necessary as building the indexing structure\nis time-intensive on large model trees.  **Note: the  addIndexedPropery()  method can be used instead of  addProperty(name, {index:true}) .", 
            "title": "2.7 Indexing (Trie) and the index option for search"
        }, 
        {
            "location": "/links/", 
            "text": "", 
            "title": "Links"
        }
    ]
}