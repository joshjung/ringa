{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Ringa JS!\n\n\nRinga JS is an enterprise single page application (SPA) framework that provides:\n\n\n\n\nMV* Architecture\n\n\nState Management\n\n\nObserver Pattern\n\n\nDependency Injection\n\n\nAsynchronous Toolset\n\n\nError Management\n\n\nCore focus on performance, modularity, and scalability\n\n\nZero dependencies on any other frameworks (pure JS)\n\n\n\n\nPlugins\n\n\nRinga JS integrates with your React application through the \nreact-ringa\n plugin.\n\n\nReact Components\n\n\nI am currently in the process of developing a large library of React components based on Ringa. The end goal is to have all the components you could possibly need to build a high-quality React application in one place:\n\n\n\n\nTooltips\n\n\nDrag and Drop\n\n\nList\n\n\nDropdown\n\n\nData Grid\n\n\nModals\n\n\nOverlays\n\n\nand much, much more\n\n\n\n\nStay tuned for more information! This should be available by end of 2017.\n\n\nLatest Versions\n\n\n\n\n\n\nringa \n\n\n\n\n\n\nreact-ringa \n\n\n\n\n\n\nMinified Size\n\n\n\n\nringa\n: \n~133kb\n\n\nreact-ringa\n: \n~8kb\n\n\n\n\nComparisons\n\n\nRinga JS is an all-in-one solution that can be used alongside your current state management / asynchronous library. However, Ringa is designed to entirely replace your current mix of dozens of libraries and plugins.\n\n\nIn today's world hooking together a collection of small libraries (e.g. one for state management and another for promise management and another for observer pattern, etc.) can be quite frustrating. It is especially frustrating if you know that you will need to train a new developer in your unique mix of code. Ringa JS is designed to alleviate these problems\nby giving you all the features you need in one place through a unified framework.\n\n\nThis chart is subject to update. There are a lot of libraries out there and I may have missed some or their capabilities. If I missed something, let me know! \n\n\n\n\n\n\n\n\nProject\n\n\nState Management\n\n\nObserver Pattern\n\n\nDependency Injection\n\n\nAsynchronous Tools\n\n\nError Handling\n\n\nHandles DOM Events\n\n\nUnit Test Ready\n\n\n\n\n\n\n\n\n\n\nRinga\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nComing Soon\n\n\n\n\n\n\nRedux\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nYes\n *\n\n\nNo\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nMobX\n\n\nYes\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nNo\n\n\nNo\n\n\nYes\n\n\n\n\n\n\n\n\n* With plugin usage.\n\n\nRequirements\n\n\nRinga JS is being developed for an ES6+ development environment (transpiled ES5 artifacts are available).\n\n\nCompatibility\n\n\n\n\nChrome\n\n\nFirefox\n\n\nSafari\n\n\nIE 10+\n\n\nEdge\n\n\nNative Node (through use of the Ringa \nBus\n instead of DOM nodes)\n\n\n\n\nInstallation\n\n\n\n\nnpm install --save-dev ringa\n - Install Ringa JS into your project\n\n\n\n\nTesting and Coverage\n\n\nnpm run test\n\n\nRinga JS currently has 208 unit tests to ensure its core features are running smoothly.\n\n\nOur goal is 100% coverage so there is a little work to do!\n\n\n\n\nWhen should I use it?\n\n\nRingaJS is right for you if you find yourself dealing with:\n\n\n\n\nBoilerplate Code\n\n\nNeed seamless integration between components in a large library\n\n\nChains of asynchronous code\n\n\nComplicated intercomponent communication\n\n\nComplex state managemetn\n\n\nApplication scalability issues\n\n\nTrouble refactoring large portions of your view\n\n\n\n\nBoilerplate\n\n\nRingaJS uses very little boilerplate code. \n\n\nAsynchronous Code\n\n\nRingaJS has an advanced built-in system for hooking chains of complicated asynchronous code together so they talk to eachother seamlessly and have intelligent fallbacks for any error, whether a thrown JS error or an API error.\n\n\nIntercomponent Communication\n\n\nRingaJS lets all controllers in your application talk to eachother by default through DOM elements. This means your controllers are one with your view, while also being able to talk to each other through the natural tree structure of your view.\n\n\nState\n\n\nRingaJS uses dependency injection, the observer pattern, and the natural tree structure of your application for its state management without needing any singletons.\n\n\nScalability\n\n\nRingaJS's architecture strongly encourages heavy decoupling and reusability of all of your code, from models, to asynchronous code, to your view. This leads to highly scalable code as your program grows.\n\n\nRefactoring\n\n\nRingaJS's structure makes refactoring large swaths of your view, models, or control easy because of its strict use of dependency injection, simple use of the observer pattern, and unique ability to reuse large sections of asynchronous code.\n\n\nBackground\n\n\nRingaJS was built in my spare time the last year as a way to shift the most difficult\nconcepts of rapid application development into a library to improve my own personal development speed. It was also designed as a way to organize enterprise\napplications in a way that made it extremely easy to monitor teams as they work in a growing codebase.\n\n\nContributors and Contact\n\n\n\n\nJoshua Jung - Project Owner\n\n\nThomas Yarnall\n\n\nJimmy Schwarzenberger\n\n\nSaajan Sn\n\n\nNaomi Mathews\n\n\nMarcus Folkeryd", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-ringa-js", 
            "text": "Ringa JS is an enterprise single page application (SPA) framework that provides:   MV* Architecture  State Management  Observer Pattern  Dependency Injection  Asynchronous Toolset  Error Management  Core focus on performance, modularity, and scalability  Zero dependencies on any other frameworks (pure JS)", 
            "title": "Welcome to Ringa JS!"
        }, 
        {
            "location": "/#plugins", 
            "text": "Ringa JS integrates with your React application through the  react-ringa  plugin.", 
            "title": "Plugins"
        }, 
        {
            "location": "/#react-components", 
            "text": "I am currently in the process of developing a large library of React components based on Ringa. The end goal is to have all the components you could possibly need to build a high-quality React application in one place:   Tooltips  Drag and Drop  List  Dropdown  Data Grid  Modals  Overlays  and much, much more   Stay tuned for more information! This should be available by end of 2017.", 
            "title": "React Components"
        }, 
        {
            "location": "/#latest-versions", 
            "text": "ringa     react-ringa", 
            "title": "Latest Versions"
        }, 
        {
            "location": "/#minified-size", 
            "text": "ringa :  ~133kb  react-ringa :  ~8kb", 
            "title": "Minified Size"
        }, 
        {
            "location": "/#comparisons", 
            "text": "Ringa JS is an all-in-one solution that can be used alongside your current state management / asynchronous library. However, Ringa is designed to entirely replace your current mix of dozens of libraries and plugins.  In today's world hooking together a collection of small libraries (e.g. one for state management and another for promise management and another for observer pattern, etc.) can be quite frustrating. It is especially frustrating if you know that you will need to train a new developer in your unique mix of code. Ringa JS is designed to alleviate these problems\nby giving you all the features you need in one place through a unified framework.  This chart is subject to update. There are a lot of libraries out there and I may have missed some or their capabilities. If I missed something, let me know!      Project  State Management  Observer Pattern  Dependency Injection  Asynchronous Tools  Error Handling  Handles DOM Events  Unit Test Ready      Ringa  Yes  Yes  Yes  Yes  Yes  Yes  Coming Soon    Redux  Yes  No  No  Yes  *  No  No  Yes    MobX  Yes  Yes  No  No  No  No  Yes     * With plugin usage.", 
            "title": "Comparisons"
        }, 
        {
            "location": "/#requirements", 
            "text": "Ringa JS is being developed for an ES6+ development environment (transpiled ES5 artifacts are available).", 
            "title": "Requirements"
        }, 
        {
            "location": "/#compatibility", 
            "text": "Chrome  Firefox  Safari  IE 10+  Edge  Native Node (through use of the Ringa  Bus  instead of DOM nodes)", 
            "title": "Compatibility"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install --save-dev ringa  - Install Ringa JS into your project", 
            "title": "Installation"
        }, 
        {
            "location": "/#testing-and-coverage", 
            "text": "npm run test  Ringa JS currently has 208 unit tests to ensure its core features are running smoothly.  Our goal is 100% coverage so there is a little work to do!", 
            "title": "Testing and Coverage"
        }, 
        {
            "location": "/#when-should-i-use-it", 
            "text": "RingaJS is right for you if you find yourself dealing with:   Boilerplate Code  Need seamless integration between components in a large library  Chains of asynchronous code  Complicated intercomponent communication  Complex state managemetn  Application scalability issues  Trouble refactoring large portions of your view", 
            "title": "When should I use it?"
        }, 
        {
            "location": "/#boilerplate", 
            "text": "RingaJS uses very little boilerplate code.", 
            "title": "Boilerplate"
        }, 
        {
            "location": "/#asynchronous-code", 
            "text": "RingaJS has an advanced built-in system for hooking chains of complicated asynchronous code together so they talk to eachother seamlessly and have intelligent fallbacks for any error, whether a thrown JS error or an API error.", 
            "title": "Asynchronous Code"
        }, 
        {
            "location": "/#intercomponent-communication", 
            "text": "RingaJS lets all controllers in your application talk to eachother by default through DOM elements. This means your controllers are one with your view, while also being able to talk to each other through the natural tree structure of your view.", 
            "title": "Intercomponent Communication"
        }, 
        {
            "location": "/#state", 
            "text": "RingaJS uses dependency injection, the observer pattern, and the natural tree structure of your application for its state management without needing any singletons.", 
            "title": "State"
        }, 
        {
            "location": "/#scalability", 
            "text": "RingaJS's architecture strongly encourages heavy decoupling and reusability of all of your code, from models, to asynchronous code, to your view. This leads to highly scalable code as your program grows.", 
            "title": "Scalability"
        }, 
        {
            "location": "/#refactoring", 
            "text": "RingaJS's structure makes refactoring large swaths of your view, models, or control easy because of its strict use of dependency injection, simple use of the observer pattern, and unique ability to reuse large sections of asynchronous code.", 
            "title": "Refactoring"
        }, 
        {
            "location": "/#background", 
            "text": "RingaJS was built in my spare time the last year as a way to shift the most difficult\nconcepts of rapid application development into a library to improve my own personal development speed. It was also designed as a way to organize enterprise\napplications in a way that made it extremely easy to monitor teams as they work in a growing codebase.", 
            "title": "Background"
        }, 
        {
            "location": "/#contributors-and-contact", 
            "text": "Joshua Jung - Project Owner  Thomas Yarnall  Jimmy Schwarzenberger  Saajan Sn  Naomi Mathews  Marcus Folkeryd", 
            "title": "Contributors and Contact"
        }, 
        {
            "location": "/gettingStarted/demo/", 
            "text": "Demo\n\n\nIntroduction\n\n\nThis RingaJS demo is a large demonstration of some of the best features of RingaJS integrated with a live server. Feel free to dig through the code and \nplay around with the application, but keep in mind the codebase was not designed as a \"Hello World\" equivalent. If you are just getting started, take a look at the examples in \nHome\n.\n\n\n\n\nLive Application\n\n\nSource Code (Web)\n\n\nSource Code (Server)\n\n\n\n\n\n  \n\n\n\n\nDescription\n\n\nThis demo is like \nTodoMVC\n on steroids. It allows you to create lists of items that are associated with a token and stored in the database. You can share the lists of items with others by giving them the url.\n\n\nTechnology\n\n\nWeb\n\n\n\n\nWebpack\n\n\nBabel Transpiling to ES5\n\n\nJavascript ES6\n\n\nSCSS\n\n\n\n\nServer\n\n\n\n\nExpress\n\n\nMongoDB", 
            "title": "Live Demo"
        }, 
        {
            "location": "/gettingStarted/demo/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/gettingStarted/demo/#introduction", 
            "text": "This RingaJS demo is a large demonstration of some of the best features of RingaJS integrated with a live server. Feel free to dig through the code and \nplay around with the application, but keep in mind the codebase was not designed as a \"Hello World\" equivalent. If you are just getting started, take a look at the examples in  Home .   Live Application  Source Code (Web)  Source Code (Server)", 
            "title": "Introduction"
        }, 
        {
            "location": "/gettingStarted/demo/#description", 
            "text": "This demo is like  TodoMVC  on steroids. It allows you to create lists of items that are associated with a token and stored in the database. You can share the lists of items with others by giving them the url.", 
            "title": "Description"
        }, 
        {
            "location": "/gettingStarted/demo/#technology", 
            "text": "", 
            "title": "Technology"
        }, 
        {
            "location": "/gettingStarted/demo/#web", 
            "text": "Webpack  Babel Transpiling to ES5  Javascript ES6  SCSS", 
            "title": "Web"
        }, 
        {
            "location": "/gettingStarted/demo/#server", 
            "text": "Express  MongoDB", 
            "title": "Server"
        }, 
        {
            "location": "/gettingStarted/helloWorld/", 
            "text": "Getting Started\n\n\nThis tutorial will walk you through, step by step, how to:\n\n\n\n\nBuild a Ringa Model\n\n\nBuild a Ringa Controller\n\n\nAttach a Ringa controller to your view\n\n\nInject your model into React view Components\n\n\nRefresh a Component when a property on the Model changes\n\n\nQuickly, and Painlessly, Refactor our View\n\n\nDispatch and Handle an Events and trigger an asynchronous chain of code\n\n\n\n\nSetting Up Your Workspace\n\n\nFirst, you will want to download and install the \nRingaJS Application Template\n.\n\n\nOnce you have this running per the \nReadme.md\n instructions, you can continue!\n\n\nNote: you may want to fork the repository or clear out the .git references until we have built a Yeoman generator or something similar.\n\n\n1. Building a Ringa \nModel\n\n\nTo construct a Ringa Model, you just need to extend \nModel\n and add some properties:\n\n\nimport {Model} from 'ringa';\n\nclass HelloWorldModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('helloWorldText', 'Hello World!');\n  }\n}\n\n\n\nOr, if you want to use the shorthand:\n\n\nconst HelloWorldModel = Model.construct('HelloWorldModel', [{\n  name: 'helloWorldText',\n  default: 'Hello World!'\n}]);\n\n\n\nUnder the hood, Ringa creates custom getters and setters for each property on your model. In addition\nit can store custom options for each property. These getters, setters, and options allow Ringa to perform\nits fancy magic.\n\n\n2. Building a Ringa \nController\n\n\nControllers in Ringa link Models to your view. They also link Models to your control / asynchronous code. In many ways the Controllers in Ringa work like a traditional MVC controller (with a couple major game-changing differences which we will explain later).\n\n\nIn any case, here is a basic example of a bare-bones Controller that does virtually nothing:\n\n\nimport {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n  }\n}\n\n\n\nThis controller really does not do much. It simply \"holds\" a reference to a single instance of our super fancy and magical hello world model.\n\n\nIt's really okay if you are not impressed yet.\n\n\n3. Attach a \nController\n to your view\n\n\nNote: Ringa does not depend on React, but in the current version React is the only plugin being developed so you must suffer if you love Vue or something. But quite frankly after seeing how well Ringa works with React at keeping things clean, you might give up your current framework.\n\n\nAnd now, let us attach our beautiful Controller to an equally vapid React Component:\n\n\nimport {attach} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    return \ndiv\nThis doesn't really do anything.\n/div\n;\n  }\n}\n\n\n\nAt this point we are nearly 90% of the way to recreating Facebook! Pat yourself on the back.\n\n\n4. Inject your \nModel\n into the View\n\n\nOne of the most powerful features of Ringa, and in particular \nreact-ringa\n, is that a view component can request any Model by its type or its name. \nreact-ringa\n will look\nthrough its parent hierarchy for all controllers, and ask those controllers if they have an instance of the requested \nModel\n. If they do, the one \nclosest\n to the current Component is returned:\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel)); // Ask for an instance of HelloWorldModel\n\n    attach(this, new HelloWorldController()); // Attach the Controller (which has the instance)\n  }\n\n  render() {\n    return \ndiv\nThis starting to do something...\n/div\n;\n  }\n}\n\n\n\nIn this case, our \nHelloWorld\n component will search for the first instance of \nHelloWorldModel\n that it can find. First it looks for all Ringa Controllers within itself or its ancestors. It finds \nHelloWorldController\n, attached to itself like a barnacle. Then it searches\nthrough all of the available \nModels\n that are added to those Controllers (in our case only the \nHelloWorldController\n). It returns the first one it finds... the one that is closest in the view stack to the current Component. In this case it finds our instance of \nHelloWorldModel\n that\nwe added to our \nHelloWorldController\n.\n\n\nWhen Ringa finds a matching \nModel\n it uses the name of the \nModel\n and injects that into the Component's state object:\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Note that all Ringa Models by default have a name that is the camelcase\n    // of the Class name, so this would be named 'helloWorldModel'\n    depend(this, dependency(HelloWorldModel));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Here our instance has been injected into the state\n    const {helloWorldModel} = this.state;\n\n    return \ndiv\n{helloWorldModel.helloWorldText}\n/div\n;\n  }\n}\n\n\n\nYou may ask why we inject into \nstate\n and not \nprops\n. This was a complicated decision. Some other frameworks like Redux get around the immutability of \nprops\n by wrapping every single component that uses \nconnect\n with \nanother\n React Component so they can inject the \nstore\n.\n\n\nI just personally decided this felt silly to wrap every component in another component to work around a design decision and \nstate\n worked so I ran with it. We can discuss the philosophical ramifications of this decision later but for now it works super well.\n\n\n5. Refresh the Display When a Property Changes on a Model\n\n\nNow, clearly displaying hello world is not enough. We may, in fact, need at some point to say goodbye to the world. Perhaps it is because it is covered in a dense layer of Venusian gasses and infected with a wildly popular orange alien who keeps spewing them.\n\n\nWhatever your personal reasons may be for leaving this planet, Ringa makes it easy (in this particular example):\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Now the property *and* the model are injected into state.\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n\n      {helloWorldText}\n      \nbutton onClick={this.goodbyeWorld}\nHej D\u00e5!\n/button\n\n    \n/div\n;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}\n\n\n\nAfter close scrutiny you might have noticed that in this example we are now watching, specifically, the \nhelloWorldText\n property on our model. What this means is that whenever that property changes, we force the component to rerender itself and inject that property\ninto the state object.\n\n\n6. Quick, and Painless, Refactoring our View\n\n\nAt this point, you may wonder what all the fuss is about. You see, Ringa's power does not lie just in its low boilerplate, intuitive dependency injection, or fast observer pattern. It lies in the flexibility of restructuring your view on the fly while having to adjust the least amount of code. Moving things around and refactoring your view\nis insanely easy:\n\n\nclass HelloWorldText extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n{helloWorldText}\n/div\n;\n  }\n}\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n\n      \nHelloWorldText /\n // \n--- Take a look here\n      \nbutton onClick={this.goodbyeWorld}\nGo to Mars with Elon Musk\n/button\n\n    \n/div\n;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}\n\n\n\nBut wait, how... how does \nHelloWorldText\n know what instance of the \nHelloWorldModel\n it is supposed to use?\n\n\nNote the \nTake a look here\n comment. On that line, we create an instance of \nHelloWorldText\n. The ancestor of that instance (\nHelloWorld\n) contains a Controller that has an instance of our \nHelloWorldModel\n. So \ndepend\n easily finds an instance to inject!\n\n\nWhile at first this may be confusing, it naturally allows you to structure the tree of your view in a highly reusable and scalable way.\n\n\n7. Dispatching and Handling Asynchronous Events\n\n\nSetting properties on Models is great and all, but our application does - at some point - need to actually do something. And nobody is going to buy that our trip to mars only took like 0 milliseconds.\n\n\nFirst, we need to update our Controller so that it can receive events:\n\n\nimport {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n\n    this.addListener('goToMars', [\n      this.updateMessage('Traveling to Mars!'),\n      1000, // Wait 1000 ms\n      this.updateMessage('Getting really bored...'),\n      5000, // Wait 5000 ms\n      this.updateMessage('Perhaps hibernation should have been invented.'),\n      10000, // Wait 10000 ms\n      this.updateMessage('Finally, we have arrived!!'),\n    ]);\n  }\n\n  updateMessage(text) {\n    return (helloWorldModel) =\n {\n      helloWorldModel.helloWorldText = text;\n    };\n  }\n}\n\n\n\nSecond, we are going to create create Form and have it dispatch an event:\n\n\nimport {dispatch} from 'ringa';\n\nclass HelloWorldForm extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return \nbutton ref=\"button\" onClick={() =\n {this.onClick()}}\nBlast off!\n/button\n;\n  }\n\n  onClick() {\n    dispatch(HelloWorldController.GO_TO_MARS, {}, this.refs.button);\n  }\n}\n\n\n\nAnd that is it! Dispatching in Ringa dispatches \nthrough\n the DOM. Since all Controllers are attached to a DOM node (the root DOM node of a React Component in this case) then they can catch\nany events (including DOM events like \n'click'\n) that can be passed through the DOM. So in our \nHelloWorldForm\n we dispatch the event, it bubbles up through to be caught by our single instance of\nthe \nHelloWorldController\n.\n\n\nNote in \naddListener\n that we provide an array of functions and numbers. In Ringa, when listening for an event we can chain asynchronous and synchronous code together. Each method in the chain has\nits arguments injected by name from the context of the Controller or the detail of the dispatched event. Numbers are just a trick to sleep for some milliseconds (super useful for building onboarding wizards or transitions).\n\n\nFor a better example of this using an actual API call, take a look at the Chuck Norris example.\n\n\nConclusion\n\n\nIn this example we have shown how to easily create Ringa Models and Controllers. We highly recommend poking around some of the other examples, and if you feel really adventurous, you can take a look at\n\nringa-example-react\n for a more advanced discussion of the features of Ringa in the code comments.", 
            "title": "Hello World Tutorial"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#getting-started", 
            "text": "This tutorial will walk you through, step by step, how to:   Build a Ringa Model  Build a Ringa Controller  Attach a Ringa controller to your view  Inject your model into React view Components  Refresh a Component when a property on the Model changes  Quickly, and Painlessly, Refactor our View  Dispatch and Handle an Events and trigger an asynchronous chain of code", 
            "title": "Getting Started"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#setting-up-your-workspace", 
            "text": "First, you will want to download and install the  RingaJS Application Template .  Once you have this running per the  Readme.md  instructions, you can continue!  Note: you may want to fork the repository or clear out the .git references until we have built a Yeoman generator or something similar.", 
            "title": "Setting Up Your Workspace"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#1-building-a-ringa-model", 
            "text": "To construct a Ringa Model, you just need to extend  Model  and add some properties:  import {Model} from 'ringa';\n\nclass HelloWorldModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('helloWorldText', 'Hello World!');\n  }\n}  Or, if you want to use the shorthand:  const HelloWorldModel = Model.construct('HelloWorldModel', [{\n  name: 'helloWorldText',\n  default: 'Hello World!'\n}]);  Under the hood, Ringa creates custom getters and setters for each property on your model. In addition\nit can store custom options for each property. These getters, setters, and options allow Ringa to perform\nits fancy magic.", 
            "title": "1. Building a Ringa Model"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#2-building-a-ringa-controller", 
            "text": "Controllers in Ringa link Models to your view. They also link Models to your control / asynchronous code. In many ways the Controllers in Ringa work like a traditional MVC controller (with a couple major game-changing differences which we will explain later).  In any case, here is a basic example of a bare-bones Controller that does virtually nothing:  import {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n  }\n}  This controller really does not do much. It simply \"holds\" a reference to a single instance of our super fancy and magical hello world model.  It's really okay if you are not impressed yet.", 
            "title": "2. Building a Ringa Controller"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#3-attach-a-controller-to-your-view", 
            "text": "Note: Ringa does not depend on React, but in the current version React is the only plugin being developed so you must suffer if you love Vue or something. But quite frankly after seeing how well Ringa works with React at keeping things clean, you might give up your current framework.  And now, let us attach our beautiful Controller to an equally vapid React Component:  import {attach} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    return  div This doesn't really do anything. /div ;\n  }\n}  At this point we are nearly 90% of the way to recreating Facebook! Pat yourself on the back.", 
            "title": "3. Attach a Controller to your view"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#4-inject-your-model-into-the-view", 
            "text": "One of the most powerful features of Ringa, and in particular  react-ringa , is that a view component can request any Model by its type or its name.  react-ringa  will look\nthrough its parent hierarchy for all controllers, and ask those controllers if they have an instance of the requested  Model . If they do, the one  closest  to the current Component is returned:  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel)); // Ask for an instance of HelloWorldModel\n\n    attach(this, new HelloWorldController()); // Attach the Controller (which has the instance)\n  }\n\n  render() {\n    return  div This starting to do something... /div ;\n  }\n}  In this case, our  HelloWorld  component will search for the first instance of  HelloWorldModel  that it can find. First it looks for all Ringa Controllers within itself or its ancestors. It finds  HelloWorldController , attached to itself like a barnacle. Then it searches\nthrough all of the available  Models  that are added to those Controllers (in our case only the  HelloWorldController ). It returns the first one it finds... the one that is closest in the view stack to the current Component. In this case it finds our instance of  HelloWorldModel  that\nwe added to our  HelloWorldController .  When Ringa finds a matching  Model  it uses the name of the  Model  and injects that into the Component's state object:  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Note that all Ringa Models by default have a name that is the camelcase\n    // of the Class name, so this would be named 'helloWorldModel'\n    depend(this, dependency(HelloWorldModel));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Here our instance has been injected into the state\n    const {helloWorldModel} = this.state;\n\n    return  div {helloWorldModel.helloWorldText} /div ;\n  }\n}  You may ask why we inject into  state  and not  props . This was a complicated decision. Some other frameworks like Redux get around the immutability of  props  by wrapping every single component that uses  connect  with  another  React Component so they can inject the  store .  I just personally decided this felt silly to wrap every component in another component to work around a design decision and  state  worked so I ran with it. We can discuss the philosophical ramifications of this decision later but for now it works super well.", 
            "title": "4. Inject your Model into the View"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#5-refresh-the-display-when-a-property-changes-on-a-model", 
            "text": "Now, clearly displaying hello world is not enough. We may, in fact, need at some point to say goodbye to the world. Perhaps it is because it is covered in a dense layer of Venusian gasses and infected with a wildly popular orange alien who keeps spewing them.  Whatever your personal reasons may be for leaving this planet, Ringa makes it easy (in this particular example):  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Now the property *and* the model are injected into state.\n    const {helloWorldText} = this.state;\n\n    return  div \n      {helloWorldText}\n       button onClick={this.goodbyeWorld} Hej D\u00e5! /button \n     /div ;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}  After close scrutiny you might have noticed that in this example we are now watching, specifically, the  helloWorldText  property on our model. What this means is that whenever that property changes, we force the component to rerender itself and inject that property\ninto the state object.", 
            "title": "5. Refresh the Display When a Property Changes on a Model"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#6-quick-and-painless-refactoring-our-view", 
            "text": "At this point, you may wonder what all the fuss is about. You see, Ringa's power does not lie just in its low boilerplate, intuitive dependency injection, or fast observer pattern. It lies in the flexibility of restructuring your view on the fly while having to adjust the least amount of code. Moving things around and refactoring your view\nis insanely easy:  class HelloWorldText extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return  div {helloWorldText} /div ;\n  }\n}\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return  div \n       HelloWorldText /  //  --- Take a look here\n       button onClick={this.goodbyeWorld} Go to Mars with Elon Musk /button \n     /div ;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}  But wait, how... how does  HelloWorldText  know what instance of the  HelloWorldModel  it is supposed to use?  Note the  Take a look here  comment. On that line, we create an instance of  HelloWorldText . The ancestor of that instance ( HelloWorld ) contains a Controller that has an instance of our  HelloWorldModel . So  depend  easily finds an instance to inject!  While at first this may be confusing, it naturally allows you to structure the tree of your view in a highly reusable and scalable way.", 
            "title": "6. Quick, and Painless, Refactoring our View"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#7-dispatching-and-handling-asynchronous-events", 
            "text": "Setting properties on Models is great and all, but our application does - at some point - need to actually do something. And nobody is going to buy that our trip to mars only took like 0 milliseconds.  First, we need to update our Controller so that it can receive events:  import {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n\n    this.addListener('goToMars', [\n      this.updateMessage('Traveling to Mars!'),\n      1000, // Wait 1000 ms\n      this.updateMessage('Getting really bored...'),\n      5000, // Wait 5000 ms\n      this.updateMessage('Perhaps hibernation should have been invented.'),\n      10000, // Wait 10000 ms\n      this.updateMessage('Finally, we have arrived!!'),\n    ]);\n  }\n\n  updateMessage(text) {\n    return (helloWorldModel) =  {\n      helloWorldModel.helloWorldText = text;\n    };\n  }\n}  Second, we are going to create create Form and have it dispatch an event:  import {dispatch} from 'ringa';\n\nclass HelloWorldForm extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return  button ref=\"button\" onClick={() =  {this.onClick()}} Blast off! /button ;\n  }\n\n  onClick() {\n    dispatch(HelloWorldController.GO_TO_MARS, {}, this.refs.button);\n  }\n}  And that is it! Dispatching in Ringa dispatches  through  the DOM. Since all Controllers are attached to a DOM node (the root DOM node of a React Component in this case) then they can catch\nany events (including DOM events like  'click' ) that can be passed through the DOM. So in our  HelloWorldForm  we dispatch the event, it bubbles up through to be caught by our single instance of\nthe  HelloWorldController .  Note in  addListener  that we provide an array of functions and numbers. In Ringa, when listening for an event we can chain asynchronous and synchronous code together. Each method in the chain has\nits arguments injected by name from the context of the Controller or the detail of the dispatched event. Numbers are just a trick to sleep for some milliseconds (super useful for building onboarding wizards or transitions).  For a better example of this using an actual API call, take a look at the Chuck Norris example.", 
            "title": "7. Dispatching and Handling Asynchronous Events"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#conclusion", 
            "text": "In this example we have shown how to easily create Ringa Models and Controllers. We highly recommend poking around some of the other examples, and if you feel really adventurous, you can take a look at ringa-example-react  for a more advanced discussion of the features of Ringa in the code comments.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/gettingStarted/examples/", 
            "text": "Examples\n\n\n\n\nChuck Norris Jokes\n\n\nTodo MVC", 
            "title": "Examples"
        }, 
        {
            "location": "/gettingStarted/examples/#examples", 
            "text": "Chuck Norris Jokes  Todo MVC", 
            "title": "Examples"
        }, 
        {
            "location": "/architecture/lifecycle/", 
            "text": "Lifecycle\n\n\nThe Ringa JS lifecycle has these five stages:\n\n\n\n\nEvent Dispatch\n\n\nController Catch\n\n\nThread Execution\n\n\nModel Update\n\n\nView Refresh\n\n\n\n\nNote that for each thread execution, multiple model updates or view refreshes may occur. In addition, model updates can trigger view refreshes without an initiating event dispatch.\n\n\nEvent Dispatch\n\n\nA \nRingaEvent\n is designed to be dispatched on a DOM Node or a Ringa \nBus\n. When dispatched on a DOM node, the \nRingaEvent\n is wrapped with a Browser \nCustomEvent\n.\n\n\nLike all Events, a \ndetail\n object can be attached. The properties on the \nRingaEvent\n \ndetail\n Object are available for injection by name into methods everywhere in the rest of the lifecycle, so choose names wisely.\n\n\nController Catch\n\n\nRinga \nController\ns may at first seem like glorified event handlers, but they are far more. The Ringa \nController\n is responsible for organizing the threads that a Ringa event can trigger. This means that two \nRingaEvents\n with the same type can be dispatched at the same time and the \nController\n will make sure to keep all the execution separate and make sure that the scope of all the injections is separated.\n\n\nIn addition, the \nController\n has default management for all your API errors, any Error throws, and any custom calls to either fail or cancel the event and all its associated threads. This allows for rollback of already completed executors and custom error handling.\n\n\nControllers also have global injections-by-name into every single executor they run. As a result, this is one of the best places to attach your models and configuration needed throughout your executors.\n\n\nThread Execution\n\n\nThis is the meat and potatoes of Ringa. Every \nThread\n in Ringa is a collection of sequential executors. Each executor can be:\n\n\n\n\nCommand\n Subclass\n: if you want custom control over timeouts and reuse across threads\n\n\nExecutorAbstract\n Subclass\n: advanced custom implementations\n\n\nfunction\n: for simple tasks\n\n\nNumber\n: sleep for N milliseconds\n\n\nArray\n: execute a set of executors in parallel and wait for all of them to complete\n\n\nstring\n or \nevent(...)\n: dispatch a RingaEvent to trigger another thread and wait for it to complete\n\n\nstop\n: debugging capability to halt the thread temporarily for console inspection\n\n\niif()\n: run one executor if a condition is truthy and another if a condition is falsey\n\n\nforEach()\n: run an executor for each item in an \nArray\n sequentially\n\n\nforEachParallel()\n: run an executor for each item in an \nArray\n in parallel and wait for all to be completed\n\n\ninterval()\n: run an executor every N milliseconds until a condition is truthy\n\n\nassign()\n: merge details into the RingaEvent detail object\n\n\nspawn()\n: start an executor and do not wait for it to complete before continuing\n\n\nloop()\n: run the same executor over and over until a condition is met.\n\n\n\n\nModel Update (optional)\n\n\nDuring any executor execution, you will probably need to update models. Ringa \nModels\n are designed so that individual properties or groups of properties, when updated, can send out a signal that they have changed. You can watch these properties and make updates to the view (or other code) based on the changes.\n\n\nEach Ringa \nModel\n subclass has full control over when the view gets notified of changes. As a result, if you want to improve performance even more you can only notify the view when you want to that a change has occurred.\n\n\nView Update (optional)\n\n\nRinga extensions like \nreact-ringa\n have built-in functionality to tie in seamlessly with your favorite framework and update the smallest subset of view components necessary when a property changes. In addition, changes are batched so that if you change a property numerous times or a set of properties the associated views only get notified once per stack frame. So you can rest easy knowing your view will be updated the fewest number of times necessary.\n\n\nDiagram Summary\n\n\nThis diagram summarizes a standard flow with a single \nRingaEvent\n and a single \nController\n:", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/architecture/lifecycle/#lifecycle", 
            "text": "The Ringa JS lifecycle has these five stages:   Event Dispatch  Controller Catch  Thread Execution  Model Update  View Refresh   Note that for each thread execution, multiple model updates or view refreshes may occur. In addition, model updates can trigger view refreshes without an initiating event dispatch.", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/architecture/lifecycle/#event-dispatch", 
            "text": "A  RingaEvent  is designed to be dispatched on a DOM Node or a Ringa  Bus . When dispatched on a DOM node, the  RingaEvent  is wrapped with a Browser  CustomEvent .  Like all Events, a  detail  object can be attached. The properties on the  RingaEvent   detail  Object are available for injection by name into methods everywhere in the rest of the lifecycle, so choose names wisely.", 
            "title": "Event Dispatch"
        }, 
        {
            "location": "/architecture/lifecycle/#controller-catch", 
            "text": "Ringa  Controller s may at first seem like glorified event handlers, but they are far more. The Ringa  Controller  is responsible for organizing the threads that a Ringa event can trigger. This means that two  RingaEvents  with the same type can be dispatched at the same time and the  Controller  will make sure to keep all the execution separate and make sure that the scope of all the injections is separated.  In addition, the  Controller  has default management for all your API errors, any Error throws, and any custom calls to either fail or cancel the event and all its associated threads. This allows for rollback of already completed executors and custom error handling.  Controllers also have global injections-by-name into every single executor they run. As a result, this is one of the best places to attach your models and configuration needed throughout your executors.", 
            "title": "Controller Catch"
        }, 
        {
            "location": "/architecture/lifecycle/#thread-execution", 
            "text": "This is the meat and potatoes of Ringa. Every  Thread  in Ringa is a collection of sequential executors. Each executor can be:   Command  Subclass : if you want custom control over timeouts and reuse across threads  ExecutorAbstract  Subclass : advanced custom implementations  function : for simple tasks  Number : sleep for N milliseconds  Array : execute a set of executors in parallel and wait for all of them to complete  string  or  event(...) : dispatch a RingaEvent to trigger another thread and wait for it to complete  stop : debugging capability to halt the thread temporarily for console inspection  iif() : run one executor if a condition is truthy and another if a condition is falsey  forEach() : run an executor for each item in an  Array  sequentially  forEachParallel() : run an executor for each item in an  Array  in parallel and wait for all to be completed  interval() : run an executor every N milliseconds until a condition is truthy  assign() : merge details into the RingaEvent detail object  spawn() : start an executor and do not wait for it to complete before continuing  loop() : run the same executor over and over until a condition is met.", 
            "title": "Thread Execution"
        }, 
        {
            "location": "/architecture/lifecycle/#model-update-optional", 
            "text": "During any executor execution, you will probably need to update models. Ringa  Models  are designed so that individual properties or groups of properties, when updated, can send out a signal that they have changed. You can watch these properties and make updates to the view (or other code) based on the changes.  Each Ringa  Model  subclass has full control over when the view gets notified of changes. As a result, if you want to improve performance even more you can only notify the view when you want to that a change has occurred.", 
            "title": "Model Update (optional)"
        }, 
        {
            "location": "/architecture/lifecycle/#view-update-optional", 
            "text": "Ringa extensions like  react-ringa  have built-in functionality to tie in seamlessly with your favorite framework and update the smallest subset of view components necessary when a property changes. In addition, changes are batched so that if you change a property numerous times or a set of properties the associated views only get notified once per stack frame. So you can rest easy knowing your view will be updated the fewest number of times necessary.", 
            "title": "View Update (optional)"
        }, 
        {
            "location": "/architecture/lifecycle/#diagram-summary", 
            "text": "This diagram summarizes a standard flow with a single  RingaEvent  and a single  Controller :", 
            "title": "Diagram Summary"
        }, 
        {
            "location": "/architecture/events/", 
            "text": "Events\n\n\nOver the lifecycle of any new framework new patterns evolve in how components can communicate to each other. Like cells evolving into multicellular organisms and multicellular organisms evolving into animals so each framework tends to repeat history.\n\n\nWe decided to learn from the past and started with the basics of component communication.\n\n\nApproach 1: Components have lots of private conversations about everything\n\n\nApplications need component communication. Due to the way CPUs work and the way that most languages are constructed, the most performant and simplest way to do this is via a method:\n\n\n// Inside component2\ncomponent1.doSomething()\n\n\n\nUnfortunately, this means that \ncomponent2\n needs access to \ncomponent1\n. In order to tell \ncomponent1\n what to do, \ncomponent2\n has to know about \ncomponent1\n. As the program grows, the program becomes brittle. Changing one thing requires changing a ton of code. Bugs pop up everywhere. What if someone changes how \ncomponent1\n works? What if we need to reorganize the view? Refactoring becomes a nightmare when the structure of the application or interfaces between the components change.\n\n\nClearly we need a better way.\n\n\nApproach 2: Components yell at everyone and hope the right guy gets the message\n\n\nLet's invent some form of an event bus, like this:\n\n\neventBus.register(component1)\neventBus.register(component2)\n...\neventBus.register(componentN)\n...\neventBus.emit('someMessageForGodKnowsWho')\n\n\n\nEvery component registered with the event bus gets every message. And each component can decide what it wants to do with that message.\n\n\nOnce again, the downside is performance at scale. For example, a DOM might have upwards of thousands of elements. If each emitted event (like \n'mousemove'\n) has to be handled by every other DOM node in the DOM tree, then this means we have to do at least 10,000 operations for every event. This is slow.\n\n\nApproach 3: Components subscribe to get the notifications they want\n\n\neventBus.on('someMessage', component1.handleSomeMessage)\neventBus.on('someMessage', component2.handleSomeMessage)\neventBus.on('someOtherMessage', component3.handleSomeOtherMessage)\n...\neventBus.emit('someMessage')\n\n\n\nThis is a huge step up. Now \ncomponent3\n does not have to worry about emitted messages it does not care about.\n\n\nThere is one big problem with this approach. What if component2 needs to get the message first? \ncomponent1\n has priority because it added a listener first!\n\n\nApproach 3: Components subscribe to get the notifications they want with priority\n\n\neventBus.on('someMessage', component1.handleSomeMessage, 0)\neventBus.on('someMessage', component2.handleSomeMessage, 1)\n...\neventBus.emit('someMessage')\n\n\n\nNow in this case, \ncomponent2\n has a priority of 1 for \n'someMessage'\n and the \neventBus\n can intelligently hand the message to that component first even though `component`` asked for the message first.\n\n\nBut what if \ncomponent2\n handles the message and decides the message needs to be cancelled so nobody else can hear it?\n\n\nApproach 4: Components subscribe with priority and ability to cancel\n\n\neventBus.on('someMessage', component1.handleSomeMessage, 0)\neventBus.on('someMessage', component2.handleSomeMessage, 1)\n...\ncomponent2.handleSomeMessage('someMessage', (event) =\n {\n  event.cancel();\n});\n...\neventBus.emit(new Event('someMessage'))\n\n\n\nExcellent, now \ncomponent1\n does not get the message.\n\n\nUnfortunately, now we have a bigger problem. What if some rogue developer decides they just want to get all priority for all messages? They could just pass in a super high priority for everything and screw everyone over. What if someone gives themselves a super high priority and then cancels the event? Another developer might sit there scratching their head wondering why in the world their event listener is not working. This brings up our next problem: how is \ncomponent2\n supposed to know what \ncomponent1\n's priority is so that it can set the priority properly?\n\n\nClearly, event priorities started with a good intention but do not work well at scale, so they do not answer Question 3 or Question 4.\n\n\nApproach 5: Components communicate in a tree structure\n\n\nComputer science tells us that all structures with at least 3 items can take the form of a tree or a graph. Graphs are inherently unruly when it comes to management. After all, if everyone can talk to everyone else and nobody has priority, who is in charge?\n\n\nMost programming structures that involve communication tend to organize into a tree. Your file system, operating system processes, and almost all GUI display structures are based on trees. In a tree, parents have one or more children, and every child only has \nonly one\n parent. The parent always has complete control over the child and must have priority in handling all events. If you delete a directory, all its children are deleted, for example. If you changes permissions on a directory you naturally change the permissions on all of its descendants.\n\n\nOne reason this tree structure works so well for communication is that all communication can be accomplished in an ordered manner if we say that each node can \nonly\n communicate to:\n\n\n\n\nIts parent\n\n\nAll its children\n\n\n\n\nIf a child needs to communicate to another child, it should do so through its parent. This allows everything to talk to everything else, but with a natural order of prioritization.\n\n\nHeck, even our \neventBus\n examples above are a tree structure with one root node (the \neventBus\n) and N leaf nodes (the \ncomponent\ns) with a depth of 1. The guideline was that all leaves in the tree can only communicate to each other if they communicate through the root node. So \ncomponent1\n can only communicate to \ncomponent2\n through the \neventBus\n.\n\n\nCombining everything we have learned so far, we can communicate with our parent and all our children like so:\n\n\nclass Component {\n  constructor(parent) {\n    this.children = [];\n    this.parent = parent;\n  }\n  addChild(child) {\n    this.children.push(child);\n  }\n  emit(event) {...}\n}\n...\ncomponent.parent.emit(message);\ncomponent.children.forEach(child =\n child.emit(message);\n\n\n\nWhat if something really important happens in a child and it needs to tell \nall\n of its ancestors (parent, parent's parent, etc.) about the event?\n\n\nWe can do this:\n\n\nlet parent = component.parent;\nwhile (parent !== undefined) { // root node doesn't have a parent!\n  parent.emit('someMessage');\n  parent = parent.parent;\n}\n\n\n\nThis is nice, but it is also requires 5 lines of code. It's not very practical. Coming back to Question 2, this is not very fun to write \nevery\n time. Also more code means more bugs, so it is also not very scalable.\n\n\nSo what if we do this instead:\n\n\nclass Component {\n  emit(event) {...}\n  emitToAncestors(event) {\n    let parent = this.parent;\n    while (parent !== undefined) { // root node doesn't have a parent\n      parent.emit('someMessage');\n      parent = parent.parent;\n    }\n  }\n  emitToChildren(event) {\n    this.children.forEach(child =\n child.emit('someMessage');\n  }\n}\n\n\n\nNow we are getting somewhere. Here we can make this better by employing a principle:\n\n\nWhen a method name is duplicated with a different qualifier, refactor the qualifier into a parameter\n\n\nSo let's change it up:\n\n\nclass Component {\n  // emitToAncestors(event) {...} DELETE\n  // emitToChildren(event) {...} DELETE\n  emit(event, toAncestors, toChildren) {...}\n}\n\n\n\nMuch Better!\n\n\nUnfortunately, this means that each instance of \nComponent\n is now responsible for stepping through each ancestor and emitting the event on each one. What if an ancestor wants to stop the message from going further? With a little bit of refactoring we move \nbubblesToAncestors\n and \npropagatesToDescendents\n into the \nEvent\n:\n\n\nclass Event {\n  constructor(type, details, bubblesToAncestors, propagatesToDescendants) {...}\n  cancel() {\n    this.cancelled = true;\n  }\n}\n...\nclass Component {\n  addListener(eventType, handler) {\n    this.listeners[eventType].push(handler);\n  }\n  emit(event) {\n    if (event.cancelled) {\n      return;\n    }\n\n    // 1st Priority: Parent\n    if (event.bubblesToAncestors \n this.parent) {\n      this.parent.emit(event);\n    }\n\n    // 2nd Priority: Ourself\n    if (this.listeners[event.type] \n this.children) {\n      this.listeners[event.type].forEach(listener =\n listener(event));\n    }\n\n    // 3rd Priority: Children\n    if (event.propagatesToDescendants) {\n      this.children.forEach(child =\n child.emit(event);\n    }\n  }\n}\n...\n// Send a message to everything in the entire tree!\ncomponent1.emit(new Event('someMessage', {}, true, true);\n\n\n\nNote: some of you might notice that this is a combination of a parent walk and a breadth-first search algorithm.\n\n\nNow each item that receives the event can check to see if \nevent.bubblesToAncestors\n or \nevent.propagatesToDescendants\n is set and then emit it appropriately only if the event has not been cancelled.\n\n\nBut now we have a scaling issue again. Unfortunately \npropagatesToDescendants\n is going to be ridiculously slow if it is dispatched from the root node and there are 10,000 descendants. When a program is small and only has 100 descendants, it might be tempting to dispatch lots of events from the root node but once the program scales this is going to get exponentially slower.\n\n\nTo be on the safe side, we remove \npropagatesToDescendants\n to protect developers from ourselves.\n\n\nNow we still need a way for parents to communicate to descendants. We know that children can easily look through their ancestors and listen for events.\n\n\nWhat if we invert control and let child components listen to the root directly, similar to employees in an organization subscribing to their boss' blog:\n\n\nclass Event {\n  constructor(type, detail, bubbles);\n}\n...\nclass Component {\n  emit(event) {...}\n  on(eventType, handler) {...}\n  get parent() {\n    return parent;\n  }\n  get root() {\n    return this.parent ? this.parent.root : this;\n  }\n}\n...\nclass MyComponent {\n  constructor() {\n    // SUBSCRIBE TO ROOT MESSAGE\n    this.root.on('someImportantMessage', () =\n {\n      console.log('Yeah, so, the president just sent me an email...');\n    });\n  }\n}\n\n\n\nExcellent, now if the root node  has to say something super important, every single component has the ability to listen directly to root without root having to emit to every descendant in the application.\n\n\nFinal Approach\n\n\nNow we can take all of the principles we have discovered and build out a basic event system that works well with the natural tree structure of a browser client.\n\n\nLet's start by organizing our naming to match the way this is implemented in the DOM according to the W3C and specifications:\n\n\n\n\non()\n becomes \naddEventListener()\n\n\nemit()\n becomes \ndispatchEvent()\n\n\nget root()\n becomes \ndocument\n or \nwindow\n\n\ncancel()\n is called \nstopPropagation()\n\n\nComponent\n is \nEventTarget\n\n\nparent\n is \nparentNode\n\n\n\n\nHere is the example code with renaming:\n\n\nclass Event {\n  constructor(type, detail, bubbles);\n  stopPropagation() {...}; // cancel\n}\n...\nclass EventTarget {\n  dispatchEvent(event) {...}\n  addEventListener(eventType, handler) {...}\n  get children()\n  get parentNode()\n}\n\n\n\nNow any listener for the event in the ancestor tree can cancel the event any time it wants!\n\n\nAt this point you can take some time to explore the entire event lifecycle of the DOM. Things I have not covered include:\n\n\n\n\nstopPropagation()\n vs. \nstopImmediatePropagation()\n\n\n'capture' vs. 'bubble' phases of an events life\n\n\n\n\nNeedless to say the DOM event system across all browsers is powerful and is used for every \n'click'\n, \n'keydown'\n, \n'mousemove'\n, etc. event handled by the browser. By using \nCustomEvent\n anyone can do all communication in your program while ensuring high performance, a natural tree-structured prioritization, and separation of concerns.\n\n\nLet's Use It!\n\n\nRinga uses the built-in browser event system instead of its own event bus. The reasons for this are numerous, but here are a few that are super useful:\n\n\n\n\nReuse of concepts developers are already forced to learn\n\n\nRinga controllers can be easily given an area of responsibility depending on where on the view they are attached\n\n\nRinga controllers can respond to view events (like listening for all clicks in the capture phase to run metrics on user interaction)\n\n\nRinga controllers can communicate with each other easily through the DOM and bubbling or capture events\n\n\nBy forcing Ringa controllers to be attached to the DOM we avoid the pitfalls of singletons\n\n\nBy avoiding singletons we can easily create libraries that have both view and controllers and they can easily integrate with other versions of Ringa or even an application that does not use Ringa at all\n\n\n\n\nConclusion\n\n\nNumerous problems of program communication are solved elegantly in the tree structure provided by the DOM.\n\n\nIn Part 2, we will discuss why Ringa has chosen to adopt using this event dispatching system for all of its communication.", 
            "title": "Event System"
        }, 
        {
            "location": "/architecture/events/#events", 
            "text": "Over the lifecycle of any new framework new patterns evolve in how components can communicate to each other. Like cells evolving into multicellular organisms and multicellular organisms evolving into animals so each framework tends to repeat history.  We decided to learn from the past and started with the basics of component communication.", 
            "title": "Events"
        }, 
        {
            "location": "/architecture/events/#approach-1-components-have-lots-of-private-conversations-about-everything", 
            "text": "Applications need component communication. Due to the way CPUs work and the way that most languages are constructed, the most performant and simplest way to do this is via a method:  // Inside component2\ncomponent1.doSomething()  Unfortunately, this means that  component2  needs access to  component1 . In order to tell  component1  what to do,  component2  has to know about  component1 . As the program grows, the program becomes brittle. Changing one thing requires changing a ton of code. Bugs pop up everywhere. What if someone changes how  component1  works? What if we need to reorganize the view? Refactoring becomes a nightmare when the structure of the application or interfaces between the components change.  Clearly we need a better way.", 
            "title": "Approach 1: Components have lots of private conversations about everything"
        }, 
        {
            "location": "/architecture/events/#approach-2-components-yell-at-everyone-and-hope-the-right-guy-gets-the-message", 
            "text": "Let's invent some form of an event bus, like this:  eventBus.register(component1)\neventBus.register(component2)\n...\neventBus.register(componentN)\n...\neventBus.emit('someMessageForGodKnowsWho')  Every component registered with the event bus gets every message. And each component can decide what it wants to do with that message.  Once again, the downside is performance at scale. For example, a DOM might have upwards of thousands of elements. If each emitted event (like  'mousemove' ) has to be handled by every other DOM node in the DOM tree, then this means we have to do at least 10,000 operations for every event. This is slow.", 
            "title": "Approach 2: Components yell at everyone and hope the right guy gets the message"
        }, 
        {
            "location": "/architecture/events/#approach-3-components-subscribe-to-get-the-notifications-they-want", 
            "text": "eventBus.on('someMessage', component1.handleSomeMessage)\neventBus.on('someMessage', component2.handleSomeMessage)\neventBus.on('someOtherMessage', component3.handleSomeOtherMessage)\n...\neventBus.emit('someMessage')  This is a huge step up. Now  component3  does not have to worry about emitted messages it does not care about.  There is one big problem with this approach. What if component2 needs to get the message first?  component1  has priority because it added a listener first!", 
            "title": "Approach 3: Components subscribe to get the notifications they want"
        }, 
        {
            "location": "/architecture/events/#approach-3-components-subscribe-to-get-the-notifications-they-want-with-priority", 
            "text": "eventBus.on('someMessage', component1.handleSomeMessage, 0)\neventBus.on('someMessage', component2.handleSomeMessage, 1)\n...\neventBus.emit('someMessage')  Now in this case,  component2  has a priority of 1 for  'someMessage'  and the  eventBus  can intelligently hand the message to that component first even though `component`` asked for the message first.  But what if  component2  handles the message and decides the message needs to be cancelled so nobody else can hear it?", 
            "title": "Approach 3: Components subscribe to get the notifications they want with priority"
        }, 
        {
            "location": "/architecture/events/#approach-4-components-subscribe-with-priority-and-ability-to-cancel", 
            "text": "eventBus.on('someMessage', component1.handleSomeMessage, 0)\neventBus.on('someMessage', component2.handleSomeMessage, 1)\n...\ncomponent2.handleSomeMessage('someMessage', (event) =  {\n  event.cancel();\n});\n...\neventBus.emit(new Event('someMessage'))  Excellent, now  component1  does not get the message.  Unfortunately, now we have a bigger problem. What if some rogue developer decides they just want to get all priority for all messages? They could just pass in a super high priority for everything and screw everyone over. What if someone gives themselves a super high priority and then cancels the event? Another developer might sit there scratching their head wondering why in the world their event listener is not working. This brings up our next problem: how is  component2  supposed to know what  component1 's priority is so that it can set the priority properly?  Clearly, event priorities started with a good intention but do not work well at scale, so they do not answer Question 3 or Question 4.", 
            "title": "Approach 4: Components subscribe with priority and ability to cancel"
        }, 
        {
            "location": "/architecture/events/#approach-5-components-communicate-in-a-tree-structure", 
            "text": "Computer science tells us that all structures with at least 3 items can take the form of a tree or a graph. Graphs are inherently unruly when it comes to management. After all, if everyone can talk to everyone else and nobody has priority, who is in charge?  Most programming structures that involve communication tend to organize into a tree. Your file system, operating system processes, and almost all GUI display structures are based on trees. In a tree, parents have one or more children, and every child only has  only one  parent. The parent always has complete control over the child and must have priority in handling all events. If you delete a directory, all its children are deleted, for example. If you changes permissions on a directory you naturally change the permissions on all of its descendants.  One reason this tree structure works so well for communication is that all communication can be accomplished in an ordered manner if we say that each node can  only  communicate to:   Its parent  All its children   If a child needs to communicate to another child, it should do so through its parent. This allows everything to talk to everything else, but with a natural order of prioritization.  Heck, even our  eventBus  examples above are a tree structure with one root node (the  eventBus ) and N leaf nodes (the  component s) with a depth of 1. The guideline was that all leaves in the tree can only communicate to each other if they communicate through the root node. So  component1  can only communicate to  component2  through the  eventBus .  Combining everything we have learned so far, we can communicate with our parent and all our children like so:  class Component {\n  constructor(parent) {\n    this.children = [];\n    this.parent = parent;\n  }\n  addChild(child) {\n    this.children.push(child);\n  }\n  emit(event) {...}\n}\n...\ncomponent.parent.emit(message);\ncomponent.children.forEach(child =  child.emit(message);  What if something really important happens in a child and it needs to tell  all  of its ancestors (parent, parent's parent, etc.) about the event?  We can do this:  let parent = component.parent;\nwhile (parent !== undefined) { // root node doesn't have a parent!\n  parent.emit('someMessage');\n  parent = parent.parent;\n}  This is nice, but it is also requires 5 lines of code. It's not very practical. Coming back to Question 2, this is not very fun to write  every  time. Also more code means more bugs, so it is also not very scalable.  So what if we do this instead:  class Component {\n  emit(event) {...}\n  emitToAncestors(event) {\n    let parent = this.parent;\n    while (parent !== undefined) { // root node doesn't have a parent\n      parent.emit('someMessage');\n      parent = parent.parent;\n    }\n  }\n  emitToChildren(event) {\n    this.children.forEach(child =  child.emit('someMessage');\n  }\n}  Now we are getting somewhere. Here we can make this better by employing a principle:  When a method name is duplicated with a different qualifier, refactor the qualifier into a parameter  So let's change it up:  class Component {\n  // emitToAncestors(event) {...} DELETE\n  // emitToChildren(event) {...} DELETE\n  emit(event, toAncestors, toChildren) {...}\n}  Much Better!  Unfortunately, this means that each instance of  Component  is now responsible for stepping through each ancestor and emitting the event on each one. What if an ancestor wants to stop the message from going further? With a little bit of refactoring we move  bubblesToAncestors  and  propagatesToDescendents  into the  Event :  class Event {\n  constructor(type, details, bubblesToAncestors, propagatesToDescendants) {...}\n  cancel() {\n    this.cancelled = true;\n  }\n}\n...\nclass Component {\n  addListener(eventType, handler) {\n    this.listeners[eventType].push(handler);\n  }\n  emit(event) {\n    if (event.cancelled) {\n      return;\n    }\n\n    // 1st Priority: Parent\n    if (event.bubblesToAncestors   this.parent) {\n      this.parent.emit(event);\n    }\n\n    // 2nd Priority: Ourself\n    if (this.listeners[event.type]   this.children) {\n      this.listeners[event.type].forEach(listener =  listener(event));\n    }\n\n    // 3rd Priority: Children\n    if (event.propagatesToDescendants) {\n      this.children.forEach(child =  child.emit(event);\n    }\n  }\n}\n...\n// Send a message to everything in the entire tree!\ncomponent1.emit(new Event('someMessage', {}, true, true);  Note: some of you might notice that this is a combination of a parent walk and a breadth-first search algorithm.  Now each item that receives the event can check to see if  event.bubblesToAncestors  or  event.propagatesToDescendants  is set and then emit it appropriately only if the event has not been cancelled.  But now we have a scaling issue again. Unfortunately  propagatesToDescendants  is going to be ridiculously slow if it is dispatched from the root node and there are 10,000 descendants. When a program is small and only has 100 descendants, it might be tempting to dispatch lots of events from the root node but once the program scales this is going to get exponentially slower.  To be on the safe side, we remove  propagatesToDescendants  to protect developers from ourselves.  Now we still need a way for parents to communicate to descendants. We know that children can easily look through their ancestors and listen for events.  What if we invert control and let child components listen to the root directly, similar to employees in an organization subscribing to their boss' blog:  class Event {\n  constructor(type, detail, bubbles);\n}\n...\nclass Component {\n  emit(event) {...}\n  on(eventType, handler) {...}\n  get parent() {\n    return parent;\n  }\n  get root() {\n    return this.parent ? this.parent.root : this;\n  }\n}\n...\nclass MyComponent {\n  constructor() {\n    // SUBSCRIBE TO ROOT MESSAGE\n    this.root.on('someImportantMessage', () =  {\n      console.log('Yeah, so, the president just sent me an email...');\n    });\n  }\n}  Excellent, now if the root node  has to say something super important, every single component has the ability to listen directly to root without root having to emit to every descendant in the application.", 
            "title": "Approach 5: Components communicate in a tree structure"
        }, 
        {
            "location": "/architecture/events/#final-approach", 
            "text": "Now we can take all of the principles we have discovered and build out a basic event system that works well with the natural tree structure of a browser client.  Let's start by organizing our naming to match the way this is implemented in the DOM according to the W3C and specifications:   on()  becomes  addEventListener()  emit()  becomes  dispatchEvent()  get root()  becomes  document  or  window  cancel()  is called  stopPropagation()  Component  is  EventTarget  parent  is  parentNode   Here is the example code with renaming:  class Event {\n  constructor(type, detail, bubbles);\n  stopPropagation() {...}; // cancel\n}\n...\nclass EventTarget {\n  dispatchEvent(event) {...}\n  addEventListener(eventType, handler) {...}\n  get children()\n  get parentNode()\n}  Now any listener for the event in the ancestor tree can cancel the event any time it wants!  At this point you can take some time to explore the entire event lifecycle of the DOM. Things I have not covered include:   stopPropagation()  vs.  stopImmediatePropagation()  'capture' vs. 'bubble' phases of an events life   Needless to say the DOM event system across all browsers is powerful and is used for every  'click' ,  'keydown' ,  'mousemove' , etc. event handled by the browser. By using  CustomEvent  anyone can do all communication in your program while ensuring high performance, a natural tree-structured prioritization, and separation of concerns.", 
            "title": "Final Approach"
        }, 
        {
            "location": "/architecture/events/#lets-use-it", 
            "text": "Ringa uses the built-in browser event system instead of its own event bus. The reasons for this are numerous, but here are a few that are super useful:   Reuse of concepts developers are already forced to learn  Ringa controllers can be easily given an area of responsibility depending on where on the view they are attached  Ringa controllers can respond to view events (like listening for all clicks in the capture phase to run metrics on user interaction)  Ringa controllers can communicate with each other easily through the DOM and bubbling or capture events  By forcing Ringa controllers to be attached to the DOM we avoid the pitfalls of singletons  By avoiding singletons we can easily create libraries that have both view and controllers and they can easily integrate with other versions of Ringa or even an application that does not use Ringa at all", 
            "title": "Let's Use It!"
        }, 
        {
            "location": "/architecture/events/#conclusion", 
            "text": "Numerous problems of program communication are solved elegantly in the tree structure provided by the DOM.  In Part 2, we will discuss why Ringa has chosen to adopt using this event dispatching system for all of its communication.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/architecture/inspector/", 
            "text": "Inspector\n\n\nUnder construction", 
            "title": "Inspector"
        }, 
        {
            "location": "/architecture/inspector/#inspector", 
            "text": "Under construction", 
            "title": "Inspector"
        }, 
        {
            "location": "/architecture/debugging/", 
            "text": "Debugging\n\n\nUnder construction", 
            "title": "Debugging"
        }, 
        {
            "location": "/architecture/debugging/#debugging", 
            "text": "Under construction", 
            "title": "Debugging"
        }, 
        {
            "location": "/architecture/buildingComponentLibraries/", 
            "text": "Building Component Libraries\n\n\nUnder construction", 
            "title": "Building Component Libraries"
        }, 
        {
            "location": "/architecture/buildingComponentLibraries/#building-component-libraries", 
            "text": "Under construction", 
            "title": "Building Component Libraries"
        }, 
        {
            "location": "/docs/", 
            "text": "Documentation Guide\n\n\nGetting Started\n\n\n\n\nLifecycle\n\n\nDependency Injection\n\n\n\n\nRinga Library\n\n\n\n\nRingaObject\n\n\nRingaEvent\n\n\nController\n\n\nExecutors\n\n\nModel\n\n\nModelWatcher\n\n\nBus\n\n\ndispatch()\n\n\n\n\nReact Ringa Library\n\n\n\n\nattach()\n\n\ndepend()\n\n\nwatch()\n\n\n\n\nArchitecture\n\n\n\n\nEvent System\n\n\nControllers and Green Threads\n\n\nAsynchronous Trees\n\n\nDebugging\n\n\n\n\nGlossary\n\n\nFAQ", 
            "title": "Index"
        }, 
        {
            "location": "/docs/#documentation-guide", 
            "text": "", 
            "title": "Documentation Guide"
        }, 
        {
            "location": "/docs/#getting-started", 
            "text": "Lifecycle  Dependency Injection", 
            "title": "Getting Started"
        }, 
        {
            "location": "/docs/#ringa-library", 
            "text": "RingaObject  RingaEvent  Controller  Executors  Model  ModelWatcher  Bus  dispatch()", 
            "title": "Ringa Library"
        }, 
        {
            "location": "/docs/#react-ringa-library", 
            "text": "attach()  depend()  watch()", 
            "title": "React Ringa Library"
        }, 
        {
            "location": "/docs/#architecture", 
            "text": "Event System  Controllers and Green Threads  Asynchronous Trees  Debugging", 
            "title": "Architecture"
        }, 
        {
            "location": "/docs/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/docs/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/docs/ringaObject/", 
            "text": "RingaObject\n\n\nUnder construction", 
            "title": "RingaObject"
        }, 
        {
            "location": "/docs/ringaObject/#ringaobject", 
            "text": "Under construction", 
            "title": "RingaObject"
        }, 
        {
            "location": "/docs/ringaEvent/", 
            "text": "RingaEvent\n\n\nUnder construction", 
            "title": "RingaEvent"
        }, 
        {
            "location": "/docs/ringaEvent/#ringaevent", 
            "text": "Under construction", 
            "title": "RingaEvent"
        }, 
        {
            "location": "/docs/model/", 
            "text": "Model\n\n\n\n\nExtends \nBus\n\n\n\n\nExtends \nRingaObject\n\n\nimport {Model} from 'ringa';\n\n\n\n\n\n\nThe Ringa \nModel\n class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:\n\n\nIt provides:\n\n\n\n\nProperty management\n\n\nProperty watching\n\n\nBuilt in tree structure (optional)\n\n\nCloning (recursive)\n\n\nSerialization / deserialization (recursive)\n\n\nTrie-based indexing for search (recursive)\n\n\n\n\nExample \nUserModel\n\n\nThe following model will be used as an example throughout this document:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}\n\n\n\nIn this example, the \nUserModel\n is configured with three properties that by default:\n\n\n\n\nCan be watched for changes\n\n\nWill be included when serializing / deserializing\n\n\nWill be cloned if \nclone()\n is called\n\n\n\n\n1. Construction\n\n\nModel(name, values)\n\n\n\nThe Ringa \nModel\n constructor takes in an optional \nname\n string and optional \nvalues\n object. If the first property is an \nObject\n then it is assumed to be the \nvalues\n object.\n\n\nEvery new Ringa \nModel\n instance has the following base properties:\n\n\n\n\nid\n: inherited from \nRingaObject\n, a unique identifier for this model. A console warning will be issued if two \nRingaObjects\n contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default \nid\n is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.\n\n\nname\n: a human-readable name for the model. It is assumed that more than one model may have the same name. By default the \nname\n property is the Model class Constructor name in camelcase.\n\n\n_values\n: passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the \n_values\n property, not \nvalues\n since they are to be treated as protected members.\n\n\n\n\nUsing the example \nUserModel\n class above we could do the following:\n\n\nlet userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);\n\n\n\nOutput:\n\n\nid: UserModel1\nname: userModel\n_values: undefined\n\n\n\nThe only way to set the \nid\n property through the constructor is to use the \nvalues\n argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:\n\n\nlet userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);\n\n\n\nOutput:\n\n\nid: someCustomId\n_values: {id: 'someCustomId'}\n\n\n\nIf you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the \nvalues\n object as well:\n\n\nlet me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});\n\n\n\n1.1. \nModel.construct\n convenience syntax\n\n\nModel.construct(className, propertyArray)\n\n\n\nWhen building smaller models, a convenience method is provided which allows you to construct a \nclass\n from an array of properties.\n\n\nTo construct our \nUserModel\n class above we could do:\n\n\nimport {Model} from 'ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName', 'email']);\n\n\n\n1.2. Properties\n\n\nYou add properties to a Model with the \naddProperty\n method:\n\n\naddProperty(name, defaultValue, options);\n\n\n\n\n\nname\n: the name of the property.\n\n\ndefaultValue\n: the default value of the property.\n\n\noptions\n: a variety of options on how the property works. Discussed in the following sections.\n\n\n\n\n1.2.1. Property Names\n\n\naddProperty\n automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);\n\n\n\nOutput:\n\n\nto be or not to be\n\n\n\nNode: a future version of Ringa should attach the getter / setter for properties to the internal \nprototype\n for performance if possible.\n\n\n1.2.2. Property Defaults\n\n\nYou can specify default values for \nModel\n properties easily:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}\n\n\n\nAll properties in the \nModel\n default to \nundefined\n. In this case, we are saying the altitude should start, as it should, at \n0\n.\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.altitude);\n\n\n\nOutput:\n\n\n0\n\n\n\n1.2.3. Property Options\n\n\nThe third parameter to \naddProperty\n is an optional options \nObject\n:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}\n\n\n\nAll property options can be accessed through the \npropertyOptions\n dictionary:\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);\n\n\n\nOutput:\n\n\nThis is the altitude of the airplane.\n\n\n\nBe careful! If you accidentally pass the property options as the second parameter to \naddProperty\n they will be treated as the default value.\n\n\nNote: the following propertyOptions have special functions in Ringa and will be discussed further in the following docs:\n\n\n\n\ndescriptor\n\n\nsetParentModel\n\n\nautowatch\n\n\ndoNotNotify\n\n\nclone\n\n\ntype\n\n\nserialize\n\n\nget\n\n\nset\n\n\n\n\n1.2.4. Property Getters / Setters\n\n\nBy default, Ringa uses \nObject.defineProperty\n every time you call \naddProperty()\n to create a custom getter / setter on your model.\n\n\nHowever, you can override this quite easily:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =\n {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =\n {\n        return this._address;\n      }\n    });\n  }\n}\n\n\n\nNote: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!\n\n\n1.3. Watching\n\n\nModel's can be watched for property value changes or even custom signals.\n\n\nNote: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.\n\n\nUsing the Example Class \nUserModel\n defined at the beginning of this page, we could do the following:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';\n\n\n\nThe console will now output:\n\n\nA property has changed 'firstName': Saajan\n\n\n\n1.4. Watch Until\n\n\nModel's can be watched until a condition is met. One use case might be if you have an authorization model with a flag for being logged in. Your view could \nwatchUntil\n the user is logged in before continuing:\n\n\n\n\n\n\nwatchUntil(condition, handler, autoUnwatch = true)\n\n\nclass AuthModel = Model.construct('AuthModel', ['loggedIn']);\n\n\n...\n\n\nlet authModel = new AuthModel(); //\n\n\nauthModel.watchUntil(authModel =\n authModel.loggedIn, signal =\n {\n  console.log(\nThe user has logged in!\n);\n}, true);\n\n\n\n\n\n\nInternally the model watches all of its dispatched signals and reruns the condition check function every time. When it is truthy, then the handler is called.\n\n\nIf you set \nautoUnwatch\n to true, then the handler will only be called the first time the condition is met. If \nautoUnwatch\n is false, then the handler function will be called every time the condition is met.\n\n\n2. Advanced\n\n\nWhile all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.\n\n\n2.1. Cloning\n\n\nRinga \nModels\n can easily be cloned:\n\n\nlet userModel = new UserModel();\n\nlet clonee = userModel.clone();\n\n\n\nIn some cases you may not want to clone the \nid\n and instead want the cloned object to grab a new unique identifier:\n\n\nlet clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);\n\n\n\nOutput:\n\n\nUserModel2\n\n\n\nNote: in 2.3 we will explain how Ringa models can be structured like a tree. The \nclone()\n method is recursive on all descendants.\n\n\n2.2. Serialization\n\n\nEvery Ringa \nModel\n has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a \nModel\n tree (see section 2.3).\n\n\nBy default, only properties that have been added with \naddProperty\n are serialized or deserialized. \n\n\n2.2.1. Serializing\n\n\nTo serialize a Ringa \nModel\n:\n\n\nlet pojo = myModel.serialize();\n\n\n\nThere are lots of options for serializing Ringa models:\n\n\n\n\nOverride the \nserializeId\n getter on any \nModel\n to customize the \nid\n property for serialization.\n\n\nImplement the \nserializeProperties\n getter on any \nModel\n to return an Array of properties to be serialized for that \nModel\n.\n\n\n\n\nFor example:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());\n\n\n\nOutput\n\n\n{\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}\n\n\n\n2.2.2. Deserializing\n\n\nBasic deserialization is easy. Assuming the \nUserModel\n example used at the beginning of this page:\n\n\nlet pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});\n\n\n\nModel.deserialize\n will instantiate a new \nUserModel\n instance and populate each of its properties with values from the POJO (if they exist).\n\n\nFor simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.\n\n\nThis can be done in several ways:\n\n\n\n\nProvide a \ntype\n option for the root model\n\n\nSet \ntype\n on the property option (for properties)\n\n\nProvide a \nmodelMapper\n \nFunction\n to the deserialize options.\n\n\n\n\n2.2.2.1. Deserializing: \ntype\n option\n\n\nAs shown above, you can provide a \ntype\n property to the deserialize options:\n\n\nlet myModel = Model.deserialize(pojo, {\n  type: MyModel\n});\n\n\n\nNote that the type provided must extend \nModel\n.\n\n\n2.2.2.2. Deserializing: \ntype\n property option\n\n\nFor individual properties, you can specify the type when calling \naddProperty\n (including Arrays) and deserialization will instantiate a new \nModel\n of that type and deserialize into it:\n\n\nclass FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});\n\n\n\nIn this case, three instances of \nFamilyTreeNode\n will be constructed, and two of them will exist inside of the \nchildren\n property of the parent node.\n\n\n2.2.2.3. Deserializing: \nmodelMapper\n option\n\n\nIn some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.\n\n\nFor this situation, you can use the \nmodelMapper\n \nFunction\n option:\n\n\nclass TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =\n {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});\n\n\n\nIn this example, if \nsomePojo\n has a property named \ntext\n then the deserializer will make a new \nTextModel\n. If it has a property named \nnumber\n then the deserializer will\nmake a \nNumberModel\n.\n\n\nNote: the \nmodelMapper\n is passed recursively in the same options object to all descendants that are deserialized as well.\n\n\n2.3. Trees\n\n\nRinga Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.\n\n\nIn addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.\n\n\n2.3.1. Autowatching and linking child \nModels\n\n\nEvery \nModel\n object watches each property for changes and if a property is set to another \nModel\n object then an internal tree structure is automatically created:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);\n\n\n\nOutput:\n\n\nParent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}\n\n\n\nIn addition to watching their properties and linking to their child \nModels\n, every \nModel\n by default watches every single child \nModel\n for property changes and dispatches a dot-notation signal when any descendant has a change:\n\n\n...\nparent.watch(signal =\n console.log);\n\nchild.text = 'Hello World';\n\n\n\nOutput:\n\n\nchild.text\n\n\n\nThe purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.\n\n\nFor example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.\n\n\n2.3.2. Watching child \nModels\n in Arrays or Objects\n\n\nNote that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call \naddModelChild\n:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);\n\n\n\nThe first argument to \naddModelChild\n is the property that the parent can find that child within.\n\n\nThe reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.\n\n\n2.4. Notifications / \nnotify()\n\n\nBy default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.\n\n\nuser.watch(signal =\n console.log);\n\nuser.firstName = 'Josh');\n\n\n\nOutput:\n\n\nfirstName\n\n\n\nBut if the property does not change in value, then no signal is dispatched:\n\n\n// Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';\n\n\n\nThe handler method for a notification has the following signature:\n\n\nmyModel.watch((signal, signaler, value, descriptor) =\n {});\n\n\n\n\n\nsignal\n: the String signal (e.g. \n'firstName'\n). Will match the property name that has changed by default.\n\n\nsignaler\n: the \nModel\n that dispatched the signal. Useful in Model trees.\n\n\nvalue\n: the value of the property that changed (if associated with a property).\n\n\ndescriptor\n: a plain-text description of the signal (intended for use with a history feature).\n\n\n\n\n2.4.1. Custom Notifications\n\n\nOne cool feature of the Ringa \nModel\n is that you can notify your own custom signals:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');\n\n\n\n2.4.2. Turning off Notifications\n\n\nFor the sake of performance, you can turn off notifications by using the property option \ndoNotNotify\n:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');\n\n\n\nIn the above example, we notify a special event when either the \nfirstName\n or \nlastName\n has changed. This structure keeps the properties\n\nfirstName\n and \nlastName\n in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.\n\n\nAlso note that the property \nfullName\n - which may be useful in your view - is not included in the serialization / deserialization or cloning.\n\n\nThis is the standard way that I recommend implementing aggregate properties. \n\n\n2.5. Aggregate Properties\n\n\nA lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.\n\n\nUnfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:\n\n\n\n\nBindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.\n\n\nIncluding complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.\n\n\n\n\nMy goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.\n\n\n2.6. Watching property changes with \nonChange\n\n\nIf you want to do complex operations, you can do so like this:\n\n\nimport {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =\n {\n        this.notify('items');\n      }\n    });\n  }\n}\n\n\n\nNote: \nonChange\n only gets called if the value of the property \nfilter\n above actually changes to a new value.\n\n\nNow, when \nfilter\n changes, an \nitems\n signal will be dispatched:\n\n\nlet collection = new Collection();\n\ncollection.watch(signal =\n {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =\n value !== 2;\n\n\n\nOutput:\n\n\n1, 3\n\n\n\nThis notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.\n\n\n2.7 Indexing (Trie) and the \nindex\n option for search\n\n\nThe Ringa \nModel\n object allows you to index your models (recursively) using a fast-lookup \nTrie search\n. This is especially useful for type-ahead\nsearches:\n\n\nclass TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeply nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');\n\n\n\nIn this example, the call to \nindex()\n builds a new Trie internal to the root \ntree\n model. It indexes every single property that has been added with \nindex\n set to true.\n\n\nThe index method has the following signature:\n\n\nindex(recurse = false, trieSearchOptions = {}, trieSearch = undefined)\n\n\n\n\n\nrecurse\n: whether to recurse into child models and their indexed properties.\n\n\ntrieSearchOptions\n: these options will be passed into the Trie search. See the \ndocumentation\n for details.\n\n\ntrieSearch\n: if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.\n\n\n\n\nIndexing is not performed automatically, you must call \nindex()\n yourself. Also please do not call \nindex()\n more often than is necessary as building the indexing structure\nis time-intensive on large model trees.\n\n\nNote: the \naddIndexedPropery()\n method can be used instead of \naddProperty(name, {index:true})\n.", 
            "title": "Model"
        }, 
        {
            "location": "/docs/model/#model", 
            "text": "Extends  Bus   Extends  RingaObject  import {Model} from 'ringa';    The Ringa  Model  class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:  It provides:   Property management  Property watching  Built in tree structure (optional)  Cloning (recursive)  Serialization / deserialization (recursive)  Trie-based indexing for search (recursive)", 
            "title": "Model"
        }, 
        {
            "location": "/docs/model/#example-usermodel", 
            "text": "The following model will be used as an example throughout this document:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}  In this example, the  UserModel  is configured with three properties that by default:   Can be watched for changes  Will be included when serializing / deserializing  Will be cloned if  clone()  is called", 
            "title": "Example UserModel"
        }, 
        {
            "location": "/docs/model/#1-construction", 
            "text": "Model(name, values)  The Ringa  Model  constructor takes in an optional  name  string and optional  values  object. If the first property is an  Object  then it is assumed to be the  values  object.  Every new Ringa  Model  instance has the following base properties:   id : inherited from  RingaObject , a unique identifier for this model. A console warning will be issued if two  RingaObjects  contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default  id  is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.  name : a human-readable name for the model. It is assumed that more than one model may have the same name. By default the  name  property is the Model class Constructor name in camelcase.  _values : passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the  _values  property, not  values  since they are to be treated as protected members.   Using the example  UserModel  class above we could do the following:  let userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);  Output:  id: UserModel1\nname: userModel\n_values: undefined  The only way to set the  id  property through the constructor is to use the  values  argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:  let userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);  Output:  id: someCustomId\n_values: {id: 'someCustomId'}  If you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the  values  object as well:  let me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});", 
            "title": "1. Construction"
        }, 
        {
            "location": "/docs/model/#11-modelconstruct-convenience-syntax", 
            "text": "Model.construct(className, propertyArray)  When building smaller models, a convenience method is provided which allows you to construct a  class  from an array of properties.  To construct our  UserModel  class above we could do:  import {Model} from 'ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName', 'email']);", 
            "title": "1.1. Model.construct convenience syntax"
        }, 
        {
            "location": "/docs/model/#12-properties", 
            "text": "You add properties to a Model with the  addProperty  method:  addProperty(name, defaultValue, options);   name : the name of the property.  defaultValue : the default value of the property.  options : a variety of options on how the property works. Discussed in the following sections.", 
            "title": "1.2. Properties"
        }, 
        {
            "location": "/docs/model/#121-property-names", 
            "text": "addProperty  automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);  Output:  to be or not to be  Node: a future version of Ringa should attach the getter / setter for properties to the internal  prototype  for performance if possible.", 
            "title": "1.2.1. Property Names"
        }, 
        {
            "location": "/docs/model/#122-property-defaults", 
            "text": "You can specify default values for  Model  properties easily:  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}  All properties in the  Model  default to  undefined . In this case, we are saying the altitude should start, as it should, at  0 .  let airplane = new Airplane();\n\nconsole.log(airplane.altitude);  Output:  0", 
            "title": "1.2.2. Property Defaults"
        }, 
        {
            "location": "/docs/model/#123-property-options", 
            "text": "The third parameter to  addProperty  is an optional options  Object :  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}  All property options can be accessed through the  propertyOptions  dictionary:  let airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);  Output:  This is the altitude of the airplane.  Be careful! If you accidentally pass the property options as the second parameter to  addProperty  they will be treated as the default value.  Note: the following propertyOptions have special functions in Ringa and will be discussed further in the following docs:   descriptor  setParentModel  autowatch  doNotNotify  clone  type  serialize  get  set", 
            "title": "1.2.3. Property Options"
        }, 
        {
            "location": "/docs/model/#124-property-getters-setters", 
            "text": "By default, Ringa uses  Object.defineProperty  every time you call  addProperty()  to create a custom getter / setter on your model.  However, you can override this quite easily:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =  {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =  {\n        return this._address;\n      }\n    });\n  }\n}  Note: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!", 
            "title": "1.2.4. Property Getters / Setters"
        }, 
        {
            "location": "/docs/model/#13-watching", 
            "text": "Model's can be watched for property value changes or even custom signals.  Note: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.  Using the Example Class  UserModel  defined at the beginning of this page, we could do the following:  let user = new UserModel();\n\nuser.watch(signal =  {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';  The console will now output:  A property has changed 'firstName': Saajan", 
            "title": "1.3. Watching"
        }, 
        {
            "location": "/docs/model/#14-watch-until", 
            "text": "Model's can be watched until a condition is met. One use case might be if you have an authorization model with a flag for being logged in. Your view could  watchUntil  the user is logged in before continuing:    watchUntil(condition, handler, autoUnwatch = true)  class AuthModel = Model.construct('AuthModel', ['loggedIn']);  ...  let authModel = new AuthModel(); //  authModel.watchUntil(authModel =  authModel.loggedIn, signal =  {\n  console.log( The user has logged in! );\n}, true);    Internally the model watches all of its dispatched signals and reruns the condition check function every time. When it is truthy, then the handler is called.  If you set  autoUnwatch  to true, then the handler will only be called the first time the condition is met. If  autoUnwatch  is false, then the handler function will be called every time the condition is met.", 
            "title": "1.4. Watch Until"
        }, 
        {
            "location": "/docs/model/#2-advanced", 
            "text": "While all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.", 
            "title": "2. Advanced"
        }, 
        {
            "location": "/docs/model/#21-cloning", 
            "text": "Ringa  Models  can easily be cloned:  let userModel = new UserModel();\n\nlet clonee = userModel.clone();  In some cases you may not want to clone the  id  and instead want the cloned object to grab a new unique identifier:  let clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);  Output:  UserModel2  Note: in 2.3 we will explain how Ringa models can be structured like a tree. The  clone()  method is recursive on all descendants.", 
            "title": "2.1. Cloning"
        }, 
        {
            "location": "/docs/model/#22-serialization", 
            "text": "Every Ringa  Model  has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a  Model  tree (see section 2.3).  By default, only properties that have been added with  addProperty  are serialized or deserialized.", 
            "title": "2.2. Serialization"
        }, 
        {
            "location": "/docs/model/#221-serializing", 
            "text": "To serialize a Ringa  Model :  let pojo = myModel.serialize();  There are lots of options for serializing Ringa models:   Override the  serializeId  getter on any  Model  to customize the  id  property for serialization.  Implement the  serializeProperties  getter on any  Model  to return an Array of properties to be serialized for that  Model .   For example:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());  Output  {\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}", 
            "title": "2.2.1. Serializing"
        }, 
        {
            "location": "/docs/model/#222-deserializing", 
            "text": "Basic deserialization is easy. Assuming the  UserModel  example used at the beginning of this page:  let pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});  Model.deserialize  will instantiate a new  UserModel  instance and populate each of its properties with values from the POJO (if they exist).  For simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.  This can be done in several ways:   Provide a  type  option for the root model  Set  type  on the property option (for properties)  Provide a  modelMapper   Function  to the deserialize options.", 
            "title": "2.2.2. Deserializing"
        }, 
        {
            "location": "/docs/model/#2221-deserializing-type-option", 
            "text": "As shown above, you can provide a  type  property to the deserialize options:  let myModel = Model.deserialize(pojo, {\n  type: MyModel\n});  Note that the type provided must extend  Model .", 
            "title": "2.2.2.1. Deserializing: type option"
        }, 
        {
            "location": "/docs/model/#2222-deserializing-type-property-option", 
            "text": "For individual properties, you can specify the type when calling  addProperty  (including Arrays) and deserialization will instantiate a new  Model  of that type and deserialize into it:  class FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});  In this case, three instances of  FamilyTreeNode  will be constructed, and two of them will exist inside of the  children  property of the parent node.", 
            "title": "2.2.2.2. Deserializing: type property option"
        }, 
        {
            "location": "/docs/model/#2223-deserializing-modelmapper-option", 
            "text": "In some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.  For this situation, you can use the  modelMapper   Function  option:  class TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =  {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});  In this example, if  somePojo  has a property named  text  then the deserializer will make a new  TextModel . If it has a property named  number  then the deserializer will\nmake a  NumberModel .  Note: the  modelMapper  is passed recursively in the same options object to all descendants that are deserialized as well.", 
            "title": "2.2.2.3. Deserializing: modelMapper option"
        }, 
        {
            "location": "/docs/model/#23-trees", 
            "text": "Ringa Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.  In addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.", 
            "title": "2.3. Trees"
        }, 
        {
            "location": "/docs/model/#231-autowatching-and-linking-child-models", 
            "text": "Every  Model  object watches each property for changes and if a property is set to another  Model  object then an internal tree structure is automatically created:  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);  Output:  Parent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}  In addition to watching their properties and linking to their child  Models , every  Model  by default watches every single child  Model  for property changes and dispatches a dot-notation signal when any descendant has a change:  ...\nparent.watch(signal =  console.log);\n\nchild.text = 'Hello World';  Output:  child.text  The purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.  For example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.", 
            "title": "2.3.1. Autowatching and linking child Models"
        }, 
        {
            "location": "/docs/model/#232-watching-child-models-in-arrays-or-objects", 
            "text": "Note that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call  addModelChild :  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);  The first argument to  addModelChild  is the property that the parent can find that child within.  The reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.", 
            "title": "2.3.2. Watching child Models in Arrays or Objects"
        }, 
        {
            "location": "/docs/model/#24-notifications-notify", 
            "text": "By default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.  user.watch(signal =  console.log);\n\nuser.firstName = 'Josh');  Output:  firstName  But if the property does not change in value, then no signal is dispatched:  // Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';  The handler method for a notification has the following signature:  myModel.watch((signal, signaler, value, descriptor) =  {});   signal : the String signal (e.g.  'firstName' ). Will match the property name that has changed by default.  signaler : the  Model  that dispatched the signal. Useful in Model trees.  value : the value of the property that changed (if associated with a property).  descriptor : a plain-text description of the signal (intended for use with a history feature).", 
            "title": "2.4. Notifications / notify()"
        }, 
        {
            "location": "/docs/model/#241-custom-notifications", 
            "text": "One cool feature of the Ringa  Model  is that you can notify your own custom signals:  let user = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');", 
            "title": "2.4.1. Custom Notifications"
        }, 
        {
            "location": "/docs/model/#242-turning-off-notifications", 
            "text": "For the sake of performance, you can turn off notifications by using the property option  doNotNotify :  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');  In the above example, we notify a special event when either the  firstName  or  lastName  has changed. This structure keeps the properties firstName  and  lastName  in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.  Also note that the property  fullName  - which may be useful in your view - is not included in the serialization / deserialization or cloning.  This is the standard way that I recommend implementing aggregate properties.", 
            "title": "2.4.2. Turning off Notifications"
        }, 
        {
            "location": "/docs/model/#25-aggregate-properties", 
            "text": "A lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.  Unfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:   Bindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.  Including complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.   My goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.", 
            "title": "2.5. Aggregate Properties"
        }, 
        {
            "location": "/docs/model/#26-watching-property-changes-with-onchange", 
            "text": "If you want to do complex operations, you can do so like this:  import {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =  {\n        this.notify('items');\n      }\n    });\n  }\n}  Note:  onChange  only gets called if the value of the property  filter  above actually changes to a new value.  Now, when  filter  changes, an  items  signal will be dispatched:  let collection = new Collection();\n\ncollection.watch(signal =  {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =  value !== 2;  Output:  1, 3  This notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.", 
            "title": "2.6. Watching property changes with onChange"
        }, 
        {
            "location": "/docs/model/#27-indexing-trie-and-the-index-option-for-search", 
            "text": "The Ringa  Model  object allows you to index your models (recursively) using a fast-lookup  Trie search . This is especially useful for type-ahead\nsearches:  class TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeply nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');  In this example, the call to  index()  builds a new Trie internal to the root  tree  model. It indexes every single property that has been added with  index  set to true.  The index method has the following signature:  index(recurse = false, trieSearchOptions = {}, trieSearch = undefined)   recurse : whether to recurse into child models and their indexed properties.  trieSearchOptions : these options will be passed into the Trie search. See the  documentation  for details.  trieSearch : if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.   Indexing is not performed automatically, you must call  index()  yourself. Also please do not call  index()  more often than is necessary as building the indexing structure\nis time-intensive on large model trees.  Note: the  addIndexedPropery()  method can be used instead of  addProperty(name, {index:true}) .", 
            "title": "2.7 Indexing (Trie) and the index option for search"
        }, 
        {
            "location": "/docs/controller/", 
            "text": "Controller\n\n\nUnder construction", 
            "title": "Controller"
        }, 
        {
            "location": "/docs/controller/#controller", 
            "text": "Under construction", 
            "title": "Controller"
        }, 
        {
            "location": "/docs/executors/", 
            "text": "Executors\n\n\nUnder construction", 
            "title": "Executors"
        }, 
        {
            "location": "/docs/executors/#executors", 
            "text": "Under construction", 
            "title": "Executors"
        }, 
        {
            "location": "/docs/reactRinga/", 
            "text": "react-ringa\n\n\nUnder construction", 
            "title": "React Ringa"
        }, 
        {
            "location": "/docs/reactRinga/#react-ringa", 
            "text": "Under construction", 
            "title": "react-ringa"
        }, 
        {
            "location": "/reactLibrary/introduction/", 
            "text": "Introduction\n\n\nUnder construction", 
            "title": "Introduction"
        }, 
        {
            "location": "/reactLibrary/introduction/#introduction", 
            "text": "Under construction", 
            "title": "Introduction"
        }, 
        {
            "location": "/reactLibrary/core/", 
            "text": "Core\n\n\nUnder construction", 
            "title": "Core"
        }, 
        {
            "location": "/reactLibrary/core/#core", 
            "text": "Under construction", 
            "title": "Core"
        }, 
        {
            "location": "/reactLibrary/overlays/", 
            "text": "Overlays\n\n\nUnder construction", 
            "title": "Overlays"
        }, 
        {
            "location": "/reactLibrary/overlays/#overlays", 
            "text": "Under construction", 
            "title": "Overlays"
        }, 
        {
            "location": "/reactLibrary/modals/", 
            "text": "Modals\n\n\nUnder construction", 
            "title": "Modals"
        }, 
        {
            "location": "/reactLibrary/modals/#modals", 
            "text": "Under construction", 
            "title": "Modals"
        }, 
        {
            "location": "/reactLibrary/dragDrop/", 
            "text": "Drag and Drop\n\n\nUnder construction", 
            "title": "Drag and Drop"
        }, 
        {
            "location": "/reactLibrary/dragDrop/#drag-and-drop", 
            "text": "Under construction", 
            "title": "Drag and Drop"
        }, 
        {
            "location": "/links/", 
            "text": "Code\n\n\n\n\nRinga Github\n\n\nReact Ringa Github\n\n\nDemo Github\n\n\n\n\nTemplate\n\n\n\n\nRingaJS Application Template\n.\n\n\n\n\nDemo\n\n\n\n\nFull Demonstration\n\n\n\n\nVideos\n\n\n\n\nInitial Presentation\n\nSkip to about 10 minutes in.", 
            "title": "Links"
        }, 
        {
            "location": "/links/#code", 
            "text": "Ringa Github  React Ringa Github  Demo Github", 
            "title": "Code"
        }, 
        {
            "location": "/links/#template", 
            "text": "RingaJS Application Template .", 
            "title": "Template"
        }, 
        {
            "location": "/links/#demo", 
            "text": "Full Demonstration", 
            "title": "Demo"
        }, 
        {
            "location": "/links/#videos", 
            "text": "Initial Presentation \nSkip to about 10 minutes in.", 
            "title": "Videos"
        }
    ]
}