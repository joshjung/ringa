{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Ringa JS!\n\n\nRinga JS is an enterprise single page application (SPA) framework that provides:\n\n\n\n\nMV* Architecture\n\n\nState Management\n\n\nObserver Pattern\n\n\nDependency Injection\n\n\nAsynchronous Toolset\n\n\nError Management\n\n\nSingle communication paradigm between all components that depends only on the browser\n\n\nCore focus on performance, modularity, and scalability\n\n\nZero dependencies on any other frameworks (pure JS)\n\n\n\n\nClick here for an architectural overview and a \"why the hell did you make this\" explanation.\n\n\nLatest Stable Versions\n\n\n\n\nringa \n\n\nreact-ringa \n\n\nringa-fw-react \n\n\n\n\nPlugins\n\n\nRinga JS integrates with your React application through the \nreact-ringa\n plugin.\n\n\nreact-ringa\n is compatible with React 16 Fiber and React 15\n.\n\n\nReact Component Library\n\n\nDemonstration\n\n\nI am currently in the process of developing a large library of React components based on Ringa. The end goal is to have all the components you could possibly need to build a high-quality React application in one place:\n\n\n\n\nTooltips\n\n\nDrag and Drop\n\n\nList\n\n\nForm\n\n\nDropdown\n\n\nData Grid\n\n\nModals\n\n\nOverlays\n\n\nand much, much more\n\n\n\n\nStay tuned for more information! This should be available by end of 2017.\n\n\nComparisons\n\n\nRinga JS is an all-in-one solution that can be used alongside your current state management / asynchronous library. However, Ringa is designed to entirely replace your current mix of dozens of libraries and plugins.\n\n\nIn today's world hooking together a collection of small libraries (e.g. one for state management and another for promise management and another for observer pattern, etc.) can be quite frustrating. It is especially frustrating if you know that you will need to train a new developer in your unique mix of code. Ringa JS is designed to alleviate these problems\nby giving you all the features you need in one place through a unified framework.\n\n\nThis chart is subject to update. There are a lot of libraries out there and I may have missed some or their capabilities. If I missed something, let me know! \n\n\n\n\n\n\n\n\nProject\n\n\nState Management\n\n\nObserver Pattern\n\n\nDependency Injection\n\n\nAsynchronous Tools\n\n\nError Handling\n\n\nHandles DOM Events\n\n\nUnit Test Ready\n\n\n\n\n\n\n\n\n\n\nRinga\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nComing Soon\n\n\n\n\n\n\nRedux\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nYes\n *\n\n\nNo\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nMobX\n\n\nYes\n\n\nYes\n\n\nNo\n\n\nNo\n\n\nNo\n\n\nNo\n\n\nYes\n\n\n\n\n\n\n\n\n* With plugin usage.\n\n\nRequirements\n\n\nRinga JS is being developed for an ES6+ development environment (transpiled ES5 artifacts are available).\n\n\nCompatibility\n\n\n\n\nChrome\n\n\nFirefox\n\n\nSafari\n\n\nIE 11+\n\n\nEdge\n\n\nNative Node (through use of the Ringa \nBus\n instead of DOM nodes)\n\n\n\n\nIE 10 needs work because it does not recognize \n__proto__\n.\n\n\nInstallation\n\n\n\n\nnpm install --save-dev ringa\n - Install Ringa JS into your project\n\n\n\n\nMinified + GZipped Size\n\n\n\n\nringa\n: \n~29.5kb\n\n\nreact-ringa\n: \n2.7kb\n\n\n\n\nTesting and Coverage\n\n\nnpm run test\n\n\nRinga JS currently has 208 unit tests to ensure its core features are running smoothly.\n\n\nOur goal is 100% coverage so there is a little work to do!\n\n\n\n\nWhen should I use it?\n\n\nRingaJS is right for you if you:\n\n\n\n\nHate Boilerplate Code\n\n\nNeed seamless integration between components in a large library and across various versions\n\n\nWant to simplify complex chains of asynchronous code\n\n\nWant simple communication between all your components\n\n\nWant to break your enterprise application into manageable submodules\n\n\nWant to avoid singletons\n\n\nAre not sure what your final UX is going to be and want completely painless refactoring next year\n\n\nWant to be able to pass your codebase to other developers and have the entire thing be easily understood\n\n\nWant to know your application can scale from a prototype to enterprise with little refactoring\n\n\n\n\nBackground\n\n\nThe concepts of Ringa JS were originally developed around 2010 for Adobe Flex and used on a dozen enterprise applications. Since the death of Flash, I had tossed around the idea of rewriting them for Javascript.\n\n\nI built the current version of Ringa JS in my spare time the last year to improve my own development speed and out of sheer frustration at every single major state and asynchronous library on the market.\n\n\nSo far it is working super well and is highly performant on several large-scale applications. More details to come soon as the project grows!\n\n\nContributors and Contact\n\n\nIf you want to contribute, or want to ask questions, feel free to reach out. As of November, 2017 the project is under heavy active daily development:\n\n\n\n\nJoshua Jung - Project Owner\n\n\nThomas Yarnall\n\n\nJimmy Schwarzenberger\n\n\nSaajan Sn\n\n\nNaomi Mathews\n\n\nMarcus Folkeryd", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-ringa-js", 
            "text": "Ringa JS is an enterprise single page application (SPA) framework that provides:   MV* Architecture  State Management  Observer Pattern  Dependency Injection  Asynchronous Toolset  Error Management  Single communication paradigm between all components that depends only on the browser  Core focus on performance, modularity, and scalability  Zero dependencies on any other frameworks (pure JS)   Click here for an architectural overview and a \"why the hell did you make this\" explanation.", 
            "title": "Welcome to Ringa JS!"
        }, 
        {
            "location": "/#latest-stable-versions", 
            "text": "ringa   react-ringa   ringa-fw-react", 
            "title": "Latest Stable Versions"
        }, 
        {
            "location": "/#plugins", 
            "text": "Ringa JS integrates with your React application through the  react-ringa  plugin.  react-ringa  is compatible with React 16 Fiber and React 15 .", 
            "title": "Plugins"
        }, 
        {
            "location": "/#react-component-library", 
            "text": "Demonstration  I am currently in the process of developing a large library of React components based on Ringa. The end goal is to have all the components you could possibly need to build a high-quality React application in one place:   Tooltips  Drag and Drop  List  Form  Dropdown  Data Grid  Modals  Overlays  and much, much more   Stay tuned for more information! This should be available by end of 2017.", 
            "title": "React Component Library"
        }, 
        {
            "location": "/#comparisons", 
            "text": "Ringa JS is an all-in-one solution that can be used alongside your current state management / asynchronous library. However, Ringa is designed to entirely replace your current mix of dozens of libraries and plugins.  In today's world hooking together a collection of small libraries (e.g. one for state management and another for promise management and another for observer pattern, etc.) can be quite frustrating. It is especially frustrating if you know that you will need to train a new developer in your unique mix of code. Ringa JS is designed to alleviate these problems\nby giving you all the features you need in one place through a unified framework.  This chart is subject to update. There are a lot of libraries out there and I may have missed some or their capabilities. If I missed something, let me know!      Project  State Management  Observer Pattern  Dependency Injection  Asynchronous Tools  Error Handling  Handles DOM Events  Unit Test Ready      Ringa  Yes  Yes  Yes  Yes  Yes  Yes  Coming Soon    Redux  Yes  No  No  Yes  *  No  No  Yes    MobX  Yes  Yes  No  No  No  No  Yes     * With plugin usage.", 
            "title": "Comparisons"
        }, 
        {
            "location": "/#requirements", 
            "text": "Ringa JS is being developed for an ES6+ development environment (transpiled ES5 artifacts are available).", 
            "title": "Requirements"
        }, 
        {
            "location": "/#compatibility", 
            "text": "Chrome  Firefox  Safari  IE 11+  Edge  Native Node (through use of the Ringa  Bus  instead of DOM nodes)   IE 10 needs work because it does not recognize  __proto__ .", 
            "title": "Compatibility"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install --save-dev ringa  - Install Ringa JS into your project", 
            "title": "Installation"
        }, 
        {
            "location": "/#minified-gzipped-size", 
            "text": "ringa :  ~29.5kb  react-ringa :  2.7kb", 
            "title": "Minified + GZipped Size"
        }, 
        {
            "location": "/#testing-and-coverage", 
            "text": "npm run test  Ringa JS currently has 208 unit tests to ensure its core features are running smoothly.  Our goal is 100% coverage so there is a little work to do!", 
            "title": "Testing and Coverage"
        }, 
        {
            "location": "/#when-should-i-use-it", 
            "text": "RingaJS is right for you if you:   Hate Boilerplate Code  Need seamless integration between components in a large library and across various versions  Want to simplify complex chains of asynchronous code  Want simple communication between all your components  Want to break your enterprise application into manageable submodules  Want to avoid singletons  Are not sure what your final UX is going to be and want completely painless refactoring next year  Want to be able to pass your codebase to other developers and have the entire thing be easily understood  Want to know your application can scale from a prototype to enterprise with little refactoring", 
            "title": "When should I use it?"
        }, 
        {
            "location": "/#background", 
            "text": "The concepts of Ringa JS were originally developed around 2010 for Adobe Flex and used on a dozen enterprise applications. Since the death of Flash, I had tossed around the idea of rewriting them for Javascript.  I built the current version of Ringa JS in my spare time the last year to improve my own development speed and out of sheer frustration at every single major state and asynchronous library on the market.  So far it is working super well and is highly performant on several large-scale applications. More details to come soon as the project grows!", 
            "title": "Background"
        }, 
        {
            "location": "/#contributors-and-contact", 
            "text": "If you want to contribute, or want to ask questions, feel free to reach out. As of November, 2017 the project is under heavy active daily development:   Joshua Jung - Project Owner  Thomas Yarnall  Jimmy Schwarzenberger  Saajan Sn  Naomi Mathews  Marcus Folkeryd", 
            "title": "Contributors and Contact"
        }, 
        {
            "location": "/gettingStarted/demo/", 
            "text": "Demo\n\n\nIntroduction\n\n\nThis RingaJS demo is a large demonstration of some of the best features of RingaJS integrated with a live server. Feel free to dig through the code and \nplay around with the application, but keep in mind the codebase was not designed as a \"Hello World\" equivalent. If you are just getting started, take a look at the examples in \nHome\n.\n\n\n\n\nLive Application\n\n\nSource Code (Web)\n\n\nSource Code (Server)\n\n\n\n\n\n  \n\n\n\n\nDescription\n\n\nThis demo is like \nTodoMVC\n on steroids. It allows you to create lists of items that are associated with a token and stored in the database. You can share the lists of items with others by giving them the url.\n\n\nTechnology\n\n\nWeb\n\n\n\n\nWebpack\n\n\nBabel Transpiling to ES5\n\n\nJavascript ES6\n\n\nSCSS\n\n\n\n\nServer\n\n\n\n\nExpress\n\n\nMongoDB", 
            "title": "Live Demo"
        }, 
        {
            "location": "/gettingStarted/demo/#demo", 
            "text": "", 
            "title": "Demo"
        }, 
        {
            "location": "/gettingStarted/demo/#introduction", 
            "text": "This RingaJS demo is a large demonstration of some of the best features of RingaJS integrated with a live server. Feel free to dig through the code and \nplay around with the application, but keep in mind the codebase was not designed as a \"Hello World\" equivalent. If you are just getting started, take a look at the examples in  Home .   Live Application  Source Code (Web)  Source Code (Server)", 
            "title": "Introduction"
        }, 
        {
            "location": "/gettingStarted/demo/#description", 
            "text": "This demo is like  TodoMVC  on steroids. It allows you to create lists of items that are associated with a token and stored in the database. You can share the lists of items with others by giving them the url.", 
            "title": "Description"
        }, 
        {
            "location": "/gettingStarted/demo/#technology", 
            "text": "", 
            "title": "Technology"
        }, 
        {
            "location": "/gettingStarted/demo/#web", 
            "text": "Webpack  Babel Transpiling to ES5  Javascript ES6  SCSS", 
            "title": "Web"
        }, 
        {
            "location": "/gettingStarted/demo/#server", 
            "text": "Express  MongoDB", 
            "title": "Server"
        }, 
        {
            "location": "/gettingStarted/helloWorld/", 
            "text": "Getting Started\n\n\nThis tutorial will walk you through, step by step, how to:\n\n\n\n\nBuild a Ringa Model\n\n\nBuild a Ringa Controller\n\n\nAttach a Ringa controller to your view\n\n\nInject your model into React view Components\n\n\nRefresh a Component when a property on the Model changes\n\n\nQuickly, and Painlessly, Refactor our View\n\n\nDispatch and Handle an Events and trigger an asynchronous chain of code\n\n\n\n\nSetting Up Your Workspace\n\n\nFirst, you will want to download and install the \nRingaJS Application Template\n.\n\n\nOnce you have this running per the \nReadme.md\n instructions, you can continue!\n\n\nNote: you may want to fork the repository or clear out the .git references until we have built a Yeoman generator or something similar.\n\n\n1. Building a Ringa \nModel\n\n\nTo construct a Ringa Model, you just need to extend \nModel\n and add some properties:\n\n\nimport {Model} from 'ringa';\n\nclass HelloWorldModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('helloWorldText', 'Hello World!');\n  }\n}\n\n\n\nOr, if you want to use the shorthand:\n\n\nconst HelloWorldModel = Model.construct('HelloWorldModel', [{\n  name: 'helloWorldText',\n  default: 'Hello World!'\n}]);\n\n\n\nUnder the hood, Ringa creates custom getters and setters for each property on your model. In addition\nit can store custom options for each property. These getters, setters, and options allow Ringa to perform\nits fancy magic.\n\n\n2. Building a Ringa \nController\n\n\nControllers in Ringa link Models to your view. They also link Models to your control / asynchronous code. In many ways the Controllers in Ringa work like a traditional MVC controller (with a couple major game-changing differences which we will explain later).\n\n\nIn any case, here is a basic example of a bare-bones Controller that does virtually nothing:\n\n\nimport {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n  }\n}\n\n\n\nThis controller really does not do much. It simply \"holds\" a reference to a single instance of our super fancy and magical hello world model.\n\n\nIt's really okay if you are not impressed yet.\n\n\n3. Attach a \nController\n to your view\n\n\nNote: Ringa does not depend on React, but in the current version React is the only plugin being developed so you must suffer if you love Vue or something. But quite frankly after seeing how well Ringa works with React at keeping things clean, you might give up your current framework.\n\n\nAnd now, let us attach our beautiful Controller to an equally vapid React Component:\n\n\nimport {attach} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    return \ndiv\nThis doesn't really do anything.\n/div\n;\n  }\n}\n\n\n\nAt this point we are nearly 90% of the way to recreating Facebook! Pat yourself on the back.\n\n\n4. Inject your \nModel\n into the View\n\n\nOne of the most powerful features of Ringa, and in particular \nreact-ringa\n, is that a view component can request any Model by its type or its name. \nreact-ringa\n will look\nthrough its parent hierarchy for all controllers, and ask those controllers if they have an instance of the requested \nModel\n. If they do, the one \nclosest\n to the current Component is returned:\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel)); // Ask for an instance of HelloWorldModel\n\n    attach(this, new HelloWorldController()); // Attach the Controller (which has the instance)\n  }\n\n  render() {\n    return \ndiv\nThis starting to do something...\n/div\n;\n  }\n}\n\n\n\nIn this case, our \nHelloWorld\n component will search for the first instance of \nHelloWorldModel\n that it can find. First it looks for all Ringa Controllers within itself or its ancestors. It finds \nHelloWorldController\n, attached to itself like a barnacle. Then it searches\nthrough all of the available \nModels\n that are added to those Controllers (in our case only the \nHelloWorldController\n). It returns the first one it finds... the one that is closest in the view stack to the current Component. In this case it finds our instance of \nHelloWorldModel\n that\nwe added to our \nHelloWorldController\n.\n\n\nWhen Ringa finds a matching \nModel\n it uses the name of the \nModel\n and injects that into the Component's state object:\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Note that all Ringa Models by default have a name that is the camelcase\n    // of the Class name, so this would be named 'helloWorldModel'\n    depend(this, dependency(HelloWorldModel));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Here our instance has been injected into the state\n    const {helloWorldModel} = this.state;\n\n    return \ndiv\n{helloWorldModel.helloWorldText}\n/div\n;\n  }\n}\n\n\n\nYou may ask why we inject into \nstate\n and not \nprops\n. This was a complicated decision. Some other frameworks like Redux get around the immutability of \nprops\n by wrapping every single component that uses \nconnect\n with \nanother\n React Component so they can inject the \nstore\n.\n\n\nI just personally decided this felt silly to wrap every component in another component to work around a design decision and \nstate\n worked so I ran with it. We can discuss the philosophical ramifications of this decision later but for now it works super well.\n\n\n5. Refresh the Display When a Property Changes on a Model\n\n\nNow, clearly displaying hello world is not enough. We may, in fact, need at some point to say goodbye to the world. Perhaps it is because it is covered in a dense layer of Venusian gasses and infected with a wildly popular orange alien who keeps spewing them.\n\n\nWhatever your personal reasons may be for leaving this planet, Ringa makes it easy (in this particular example):\n\n\nimport {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Now the property *and* the model are injected into state.\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n\n      {helloWorldText}\n      \nbutton onClick={this.goodbyeWorld}\nHej D\u00e5!\n/button\n\n    \n/div\n;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}\n\n\n\nAfter close scrutiny you might have noticed that in this example we are now watching, specifically, the \nhelloWorldText\n property on our model. What this means is that whenever that property changes, we force the component to rerender itself and inject that property\ninto the state object.\n\n\n6. Quick, and Painless, Refactoring our View\n\n\nAt this point, you may wonder what all the fuss is about. You see, Ringa's power does not lie just in its low boilerplate, intuitive dependency injection, or fast observer pattern. It lies in the flexibility of restructuring your view on the fly while having to adjust the least amount of code. Moving things around and refactoring your view\nis insanely easy:\n\n\nclass HelloWorldText extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n{helloWorldText}\n/div\n;\n  }\n}\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return \ndiv\n\n      \nHelloWorldText /\n // \n--- Take a look here\n      \nbutton onClick={this.goodbyeWorld}\nGo to Mars with Elon Musk\n/button\n\n    \n/div\n;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}\n\n\n\nBut wait, how... how does \nHelloWorldText\n know what instance of the \nHelloWorldModel\n it is supposed to use?\n\n\nNote the \nTake a look here\n comment. On that line, we create an instance of \nHelloWorldText\n. The ancestor of that instance (\nHelloWorld\n) contains a Controller that has an instance of our \nHelloWorldModel\n. So \ndepend\n easily finds an instance to inject!\n\n\nWhile at first this may be confusing, it naturally allows you to structure the tree of your view in a highly reusable and scalable way.\n\n\n7. Dispatching and Handling Asynchronous Events\n\n\nSetting properties on Models is great and all, but our application does - at some point - need to actually do something. And nobody is going to buy that our trip to mars only took like 0 milliseconds.\n\n\nFirst, we need to update our Controller so that it can receive events:\n\n\nimport {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n\n    this.addListener('goToMars', [\n      this.updateMessage('Traveling to Mars!'),\n      1000, // Wait 1000 ms\n      this.updateMessage('Getting really bored...'),\n      5000, // Wait 5000 ms\n      this.updateMessage('Perhaps hibernation should have been invented.'),\n      10000, // Wait 10000 ms\n      this.updateMessage('Finally, we have arrived!!'),\n    ]);\n  }\n\n  updateMessage(text) {\n    return (helloWorldModel) =\n {\n      helloWorldModel.helloWorldText = text;\n    };\n  }\n}\n\n\n\nSecond, we are going to create create Form and have it dispatch an event:\n\n\nimport {dispatch} from 'ringa';\n\nclass HelloWorldForm extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return \nbutton ref=\"button\" onClick={() =\n {this.onClick()}}\nBlast off!\n/button\n;\n  }\n\n  onClick() {\n    dispatch(HelloWorldController.GO_TO_MARS, {}, this.refs.button);\n  }\n}\n\n\n\nAnd that is it! Dispatching in Ringa dispatches \nthrough\n the DOM. Since all Controllers are attached to a DOM node (the root DOM node of a React Component in this case) then they can catch\nany events (including DOM events like \n'click'\n) that can be passed through the DOM. So in our \nHelloWorldForm\n we dispatch the event, it bubbles up through to be caught by our single instance of\nthe \nHelloWorldController\n.\n\n\nNote in \naddListener\n that we provide an array of functions and numbers. In Ringa, when listening for an event we can chain asynchronous and synchronous code together. Each method in the chain has\nits arguments injected by name from the context of the Controller or the detail of the dispatched event. Numbers are just a trick to sleep for some milliseconds (super useful for building onboarding wizards or transitions).\n\n\nFor a better example of this using an actual API call, take a look at the Chuck Norris example.\n\n\nConclusion\n\n\nIn this example we have shown how to easily create Ringa Models and Controllers. We highly recommend poking around some of the other examples, and if you feel really adventurous, you can take a look at\n\nringa-example-react\n for a more advanced discussion of the features of Ringa in the code comments.", 
            "title": "Hello World Tutorial"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#getting-started", 
            "text": "This tutorial will walk you through, step by step, how to:   Build a Ringa Model  Build a Ringa Controller  Attach a Ringa controller to your view  Inject your model into React view Components  Refresh a Component when a property on the Model changes  Quickly, and Painlessly, Refactor our View  Dispatch and Handle an Events and trigger an asynchronous chain of code", 
            "title": "Getting Started"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#setting-up-your-workspace", 
            "text": "First, you will want to download and install the  RingaJS Application Template .  Once you have this running per the  Readme.md  instructions, you can continue!  Note: you may want to fork the repository or clear out the .git references until we have built a Yeoman generator or something similar.", 
            "title": "Setting Up Your Workspace"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#1-building-a-ringa-model", 
            "text": "To construct a Ringa Model, you just need to extend  Model  and add some properties:  import {Model} from 'ringa';\n\nclass HelloWorldModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('helloWorldText', 'Hello World!');\n  }\n}  Or, if you want to use the shorthand:  const HelloWorldModel = Model.construct('HelloWorldModel', [{\n  name: 'helloWorldText',\n  default: 'Hello World!'\n}]);  Under the hood, Ringa creates custom getters and setters for each property on your model. In addition\nit can store custom options for each property. These getters, setters, and options allow Ringa to perform\nits fancy magic.", 
            "title": "1. Building a Ringa Model"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#2-building-a-ringa-controller", 
            "text": "Controllers in Ringa link Models to your view. They also link Models to your control / asynchronous code. In many ways the Controllers in Ringa work like a traditional MVC controller (with a couple major game-changing differences which we will explain later).  In any case, here is a basic example of a bare-bones Controller that does virtually nothing:  import {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n  }\n}  This controller really does not do much. It simply \"holds\" a reference to a single instance of our super fancy and magical hello world model.  It's really okay if you are not impressed yet.", 
            "title": "2. Building a Ringa Controller"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#3-attach-a-controller-to-your-view", 
            "text": "Note: Ringa does not depend on React, but in the current version React is the only plugin being developed so you must suffer if you love Vue or something. But quite frankly after seeing how well Ringa works with React at keeping things clean, you might give up your current framework.  And now, let us attach our beautiful Controller to an equally vapid React Component:  import {attach} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    return  div This doesn't really do anything. /div ;\n  }\n}  At this point we are nearly 90% of the way to recreating Facebook! Pat yourself on the back.", 
            "title": "3. Attach a Controller to your view"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#4-inject-your-model-into-the-view", 
            "text": "One of the most powerful features of Ringa, and in particular  react-ringa , is that a view component can request any Model by its type or its name.  react-ringa  will look\nthrough its parent hierarchy for all controllers, and ask those controllers if they have an instance of the requested  Model . If they do, the one  closest  to the current Component is returned:  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel)); // Ask for an instance of HelloWorldModel\n\n    attach(this, new HelloWorldController()); // Attach the Controller (which has the instance)\n  }\n\n  render() {\n    return  div This starting to do something... /div ;\n  }\n}  In this case, our  HelloWorld  component will search for the first instance of  HelloWorldModel  that it can find. First it looks for all Ringa Controllers within itself or its ancestors. It finds  HelloWorldController , attached to itself like a barnacle. Then it searches\nthrough all of the available  Models  that are added to those Controllers (in our case only the  HelloWorldController ). It returns the first one it finds... the one that is closest in the view stack to the current Component. In this case it finds our instance of  HelloWorldModel  that\nwe added to our  HelloWorldController .  When Ringa finds a matching  Model  it uses the name of the  Model  and injects that into the Component's state object:  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // Note that all Ringa Models by default have a name that is the camelcase\n    // of the Class name, so this would be named 'helloWorldModel'\n    depend(this, dependency(HelloWorldModel));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Here our instance has been injected into the state\n    const {helloWorldModel} = this.state;\n\n    return  div {helloWorldModel.helloWorldText} /div ;\n  }\n}  You may ask why we inject into  state  and not  props . This was a complicated decision. Some other frameworks like Redux get around the immutability of  props  by wrapping every single component that uses  connect  with  another  React Component so they can inject the  store .  I just personally decided this felt silly to wrap every component in another component to work around a design decision and  state  worked so I ran with it. We can discuss the philosophical ramifications of this decision later but for now it works super well.", 
            "title": "4. Inject your Model into the View"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#5-refresh-the-display-when-a-property-changes-on-a-model", 
            "text": "Now, clearly displaying hello world is not enough. We may, in fact, need at some point to say goodbye to the world. Perhaps it is because it is covered in a dense layer of Venusian gasses and infected with a wildly popular orange alien who keeps spewing them.  Whatever your personal reasons may be for leaving this planet, Ringa makes it easy (in this particular example):  import {depend, dependency} from 'react-ringa';\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    // Now the property *and* the model are injected into state.\n    const {helloWorldText} = this.state;\n\n    return  div \n      {helloWorldText}\n       button onClick={this.goodbyeWorld} Hej D\u00e5! /button \n     /div ;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}  After close scrutiny you might have noticed that in this example we are now watching, specifically, the  helloWorldText  property on our model. What this means is that whenever that property changes, we force the component to rerender itself and inject that property\ninto the state object.", 
            "title": "5. Refresh the Display When a Property Changes on a Model"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#6-quick-and-painless-refactoring-our-view", 
            "text": "At this point, you may wonder what all the fuss is about. You see, Ringa's power does not lie just in its low boilerplate, intuitive dependency injection, or fast observer pattern. It lies in the flexibility of restructuring your view on the fly while having to adjust the least amount of code. Moving things around and refactoring your view\nis insanely easy:  class HelloWorldText extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(HelloWorldModel, 'helloWorldText'));\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return  div {helloWorldText} /div ;\n  }\n}\n\nclass HelloWorld extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new HelloWorldController());\n  }\n\n  render() {\n    const {helloWorldText} = this.state;\n\n    return  div \n       HelloWorldText /  //  --- Take a look here\n       button onClick={this.goodbyeWorld} Go to Mars with Elon Musk /button \n     /div ;\n  }\n\n  goodbyeWorld() {\n    this.state.helloWorldModel.helloWorldText = 'Goodbye, earth!';\n  }\n}  But wait, how... how does  HelloWorldText  know what instance of the  HelloWorldModel  it is supposed to use?  Note the  Take a look here  comment. On that line, we create an instance of  HelloWorldText . The ancestor of that instance ( HelloWorld ) contains a Controller that has an instance of our  HelloWorldModel . So  depend  easily finds an instance to inject!  While at first this may be confusing, it naturally allows you to structure the tree of your view in a highly reusable and scalable way.", 
            "title": "6. Quick, and Painless, Refactoring our View"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#7-dispatching-and-handling-asynchronous-events", 
            "text": "Setting properties on Models is great and all, but our application does - at some point - need to actually do something. And nobody is going to buy that our trip to mars only took like 0 milliseconds.  First, we need to update our Controller so that it can receive events:  import {Controller} from 'ringa';\n\nclass HelloWorldController extends Controller {\n  constructor(name, bus, options) {\n    super(name, bus, options);\n\n    this.addModel(new HelloWorldModel());\n\n    this.addListener('goToMars', [\n      this.updateMessage('Traveling to Mars!'),\n      1000, // Wait 1000 ms\n      this.updateMessage('Getting really bored...'),\n      5000, // Wait 5000 ms\n      this.updateMessage('Perhaps hibernation should have been invented.'),\n      10000, // Wait 10000 ms\n      this.updateMessage('Finally, we have arrived!!'),\n    ]);\n  }\n\n  updateMessage(text) {\n    return (helloWorldModel) =  {\n      helloWorldModel.helloWorldText = text;\n    };\n  }\n}  Second, we are going to create create Form and have it dispatch an event:  import {dispatch} from 'ringa';\n\nclass HelloWorldForm extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return  button ref=\"button\" onClick={() =  {this.onClick()}} Blast off! /button ;\n  }\n\n  onClick() {\n    dispatch(HelloWorldController.GO_TO_MARS, {}, this.refs.button);\n  }\n}  And that is it! Dispatching in Ringa dispatches  through  the DOM. Since all Controllers are attached to a DOM node (the root DOM node of a React Component in this case) then they can catch\nany events (including DOM events like  'click' ) that can be passed through the DOM. So in our  HelloWorldForm  we dispatch the event, it bubbles up through to be caught by our single instance of\nthe  HelloWorldController .  Note in  addListener  that we provide an array of functions and numbers. In Ringa, when listening for an event we can chain asynchronous and synchronous code together. Each method in the chain has\nits arguments injected by name from the context of the Controller or the detail of the dispatched event. Numbers are just a trick to sleep for some milliseconds (super useful for building onboarding wizards or transitions).  For a better example of this using an actual API call, take a look at the Chuck Norris example.", 
            "title": "7. Dispatching and Handling Asynchronous Events"
        }, 
        {
            "location": "/gettingStarted/helloWorld/#conclusion", 
            "text": "In this example we have shown how to easily create Ringa Models and Controllers. We highly recommend poking around some of the other examples, and if you feel really adventurous, you can take a look at ringa-example-react  for a more advanced discussion of the features of Ringa in the code comments.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/gettingStarted/examples/", 
            "text": "Examples\n\n\n\n\nChuck Norris Jokes\n\n\nTodo MVC", 
            "title": "Code Examples"
        }, 
        {
            "location": "/gettingStarted/examples/#examples", 
            "text": "Chuck Norris Jokes  Todo MVC", 
            "title": "Examples"
        }, 
        {
            "location": "/architecture/lifecycle/", 
            "text": "Lifecycle\n\n\nThe Ringa JS lifecycle has these five stages:\n\n\n\n\nEvent Dispatch\n\n\nController Catch\n\n\nThread Execution\n\n\nModel Update\n\n\nView Refresh\n\n\n\n\nNote that for each thread execution, multiple model updates or view refreshes may occur. In addition, model updates can trigger view refreshes without an initiating event dispatch.\n\n\nEvent Dispatch\n\n\nA \nRingaEvent\n is designed to be dispatched on a DOM Node or a Ringa \nBus\n. When dispatched on a DOM node, the \nRingaEvent\n is wrapped with a Browser \nCustomEvent\n.\n\n\nLike all Events, a \ndetail\n object can be attached. The properties on the \nRingaEvent\n \ndetail\n Object are available for injection by name into methods everywhere in the rest of the lifecycle, so choose names wisely.\n\n\nController Catch\n\n\nRinga \nController\ns may at first seem like glorified event handlers, but they are far more. The Ringa \nController\n is responsible for organizing the threads that a Ringa event can trigger. This means that two \nRingaEvents\n with the same type can be dispatched at the same time and the \nController\n will make sure to keep all the execution separate and make sure that the scope of all the injections is separated.\n\n\nIn addition, the \nController\n has default management for all your API errors, any Error throws, and any custom calls to either fail or cancel the event and all its associated threads. This allows for rollback of already completed executors and custom error handling.\n\n\nControllers also have global injections-by-name into every single executor they run. As a result, this is one of the best places to attach your models and configuration needed throughout your executors.\n\n\nThread Execution\n\n\nThis is the meat and potatoes of Ringa. Every \nThread\n in Ringa is a collection of sequential executors. Each executor can be:\n\n\n\n\nCommand\n Subclass\n: if you want custom control over timeouts and reuse across threads\n\n\nExecutorAbstract\n Subclass\n: advanced custom implementations\n\n\nfunction\n: for simple tasks\n\n\nNumber\n: sleep for N milliseconds\n\n\nArray\n: execute a set of executors in parallel and wait for all of them to complete\n\n\nstring\n or \nevent(...)\n: dispatch a RingaEvent to trigger another thread and wait for it to complete\n\n\nstop\n: debugging capability to halt the thread temporarily for console inspection\n\n\niif()\n: run one executor if a condition is truthy and another if a condition is falsey\n\n\nforEach()\n: run an executor for each item in an \nArray\n sequentially\n\n\nforEachParallel()\n: run an executor for each item in an \nArray\n in parallel and wait for all to be completed\n\n\ninterval()\n: run an executor every N milliseconds until a condition is truthy\n\n\nassign()\n: merge details into the RingaEvent detail object\n\n\nspawn()\n: start an executor and do not wait for it to complete before continuing\n\n\nloop()\n: run the same executor over and over until a condition is met.\n\n\n\n\nModel Update (optional)\n\n\nDuring any executor execution, you will probably need to update models. Ringa \nModels\n are designed so that individual properties or groups of properties, when updated, can send out a signal that they have changed. You can watch these properties and make updates to the view (or other code) based on the changes.\n\n\nEach Ringa \nModel\n subclass has full control over when the view gets notified of changes. As a result, if you want to improve performance even more you can only notify the view when you want to that a change has occurred.\n\n\nView Update (optional)\n\n\nRinga extensions like \nreact-ringa\n have built-in functionality to tie in seamlessly with your favorite framework and update the smallest subset of view components necessary when a property changes. In addition, changes are batched so that if you change a property numerous times or a set of properties the associated views only get notified once per stack frame. So you can rest easy knowing your view will be updated the fewest number of times necessary.\n\n\nDiagram Summary\n\n\nThis diagram summarizes a standard flow with a single \nRingaEvent\n and a single \nController\n:", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/architecture/lifecycle/#lifecycle", 
            "text": "The Ringa JS lifecycle has these five stages:   Event Dispatch  Controller Catch  Thread Execution  Model Update  View Refresh   Note that for each thread execution, multiple model updates or view refreshes may occur. In addition, model updates can trigger view refreshes without an initiating event dispatch.", 
            "title": "Lifecycle"
        }, 
        {
            "location": "/architecture/lifecycle/#event-dispatch", 
            "text": "A  RingaEvent  is designed to be dispatched on a DOM Node or a Ringa  Bus . When dispatched on a DOM node, the  RingaEvent  is wrapped with a Browser  CustomEvent .  Like all Events, a  detail  object can be attached. The properties on the  RingaEvent   detail  Object are available for injection by name into methods everywhere in the rest of the lifecycle, so choose names wisely.", 
            "title": "Event Dispatch"
        }, 
        {
            "location": "/architecture/lifecycle/#controller-catch", 
            "text": "Ringa  Controller s may at first seem like glorified event handlers, but they are far more. The Ringa  Controller  is responsible for organizing the threads that a Ringa event can trigger. This means that two  RingaEvents  with the same type can be dispatched at the same time and the  Controller  will make sure to keep all the execution separate and make sure that the scope of all the injections is separated.  In addition, the  Controller  has default management for all your API errors, any Error throws, and any custom calls to either fail or cancel the event and all its associated threads. This allows for rollback of already completed executors and custom error handling.  Controllers also have global injections-by-name into every single executor they run. As a result, this is one of the best places to attach your models and configuration needed throughout your executors.", 
            "title": "Controller Catch"
        }, 
        {
            "location": "/architecture/lifecycle/#thread-execution", 
            "text": "This is the meat and potatoes of Ringa. Every  Thread  in Ringa is a collection of sequential executors. Each executor can be:   Command  Subclass : if you want custom control over timeouts and reuse across threads  ExecutorAbstract  Subclass : advanced custom implementations  function : for simple tasks  Number : sleep for N milliseconds  Array : execute a set of executors in parallel and wait for all of them to complete  string  or  event(...) : dispatch a RingaEvent to trigger another thread and wait for it to complete  stop : debugging capability to halt the thread temporarily for console inspection  iif() : run one executor if a condition is truthy and another if a condition is falsey  forEach() : run an executor for each item in an  Array  sequentially  forEachParallel() : run an executor for each item in an  Array  in parallel and wait for all to be completed  interval() : run an executor every N milliseconds until a condition is truthy  assign() : merge details into the RingaEvent detail object  spawn() : start an executor and do not wait for it to complete before continuing  loop() : run the same executor over and over until a condition is met.", 
            "title": "Thread Execution"
        }, 
        {
            "location": "/architecture/lifecycle/#model-update-optional", 
            "text": "During any executor execution, you will probably need to update models. Ringa  Models  are designed so that individual properties or groups of properties, when updated, can send out a signal that they have changed. You can watch these properties and make updates to the view (or other code) based on the changes.  Each Ringa  Model  subclass has full control over when the view gets notified of changes. As a result, if you want to improve performance even more you can only notify the view when you want to that a change has occurred.", 
            "title": "Model Update (optional)"
        }, 
        {
            "location": "/architecture/lifecycle/#view-update-optional", 
            "text": "Ringa extensions like  react-ringa  have built-in functionality to tie in seamlessly with your favorite framework and update the smallest subset of view components necessary when a property changes. In addition, changes are batched so that if you change a property numerous times or a set of properties the associated views only get notified once per stack frame. So you can rest easy knowing your view will be updated the fewest number of times necessary.", 
            "title": "View Update (optional)"
        }, 
        {
            "location": "/architecture/lifecycle/#diagram-summary", 
            "text": "This diagram summarizes a standard flow with a single  RingaEvent  and a single  Controller :", 
            "title": "Diagram Summary"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/", 
            "text": "Functional Programming, Inversion of Control, and Ringa\n\n\nNote: the following article is about the architectural concepts of GUI and is not related to Javascript at all. This\ncould apply to any language that involves a tree of UI components.\n\n\nTopic Introduction\n\n\nThe last several years have seen a wave of programmers pushing harder for functional programming and using a global state\nstore to manage their applications. I designed the concepts of Ringa back before any of the modern Javascript frameworks\nand libraries were around (back in 2010) and, quite honestly, before I really understood the details of functional\nprogramming.\n\n\nAs a result, rather than try to compare Ringa's architecture directly to the pros and cons of functional programming and\na global state store, I will just provide a walkthrough of my own understanding of functional programming and inversion\nof control in an attempt to explain how I used Ringa to tackle the same problems.\n\n\nSide-effects and State\n\n\nDefining the Problem\n\n\nThere are two contexts web developers are generally referring to when discussing side-effects:\n\n\n\n\nFunctions\n\n\nVisual (GUI) Components\n\n\n\n\nIn programming languages, a function has a side effect when running it can mutate a variable outside of its scope. This\ncan make running a function \"unsafe\". If I am calling the function \nfoo()\n everywhere in my code and the developer of the\nfunction decides that he is going to wipe all the DOM nodes whenever \nfoo()\n is called, my code now no longer works. The\nsame goes for if I pass a mutable argument by reference into \nfoo()\n and \nfoo()\n decides to change all the properties\non the argument without my knowledge. Either way, \nfoo()\n is unpredictable and volatile, and like Donald Trump or Brexit,\nmust be stopped.\n\n\nLikewise, in GUI frameworks, a visual component could also reference or change other components or models that it should\nnot have access to. Or if a GUI component holds internal state properties that change between each call to render, then\neach time I render it, it could look differently even though I am telling it to render itself the same each time. \n\n\nAs a program size increases, it can become impossible for a developer to know what a specific function or visual component\nis going to do when it is called or rendered. So in both scenarios - functions or GUI components - there are massive\nbenefits to creating a pure implementation where calling the function - or rendering the visual component - is guaranteed\nto be predictable and have no side effects.\n\n\nThe problem, in short, is that we \nwant to eliminate side effects\n:\n\n\n\n\nOne solution for programming languages is to have a pure functional language like Haskell or Erlang.\n\n\nThe analogous solution for rendering a GUI is to mimic a functional language by developing pure components that\nhave a single render method with properties passed from the parent and no internal state.\n\n\n\n\nWithin React, for example, Pure components only contain a \nrender()\n function that is guaranteed to only look at\n\nthis.props\n and predictably returns the exact same DOM representation for any given props - every time.\n\n\nFunctional Advantages\n\n\nThere are massive advantages to the pure functional approach. For example, when using functional programming you can\nmemoize results of the calls. This allows you to cache (at the expense of memory) all previous calls and speed up future\nrenders of every component instance. If you can memoize what a component looks like with the same props, and render it\n1000 times on the display with the same props, you really only run the render function once.\n\n\nAnother advantage to functional is in multi-threaded or multi-core implementations. Normally, with threading we end up\nwith lots of potential for deadlock especially if multiple threads have write access to locations in memory. There are\ntons of unique ways to solve this problem, but they generally involve forcing one core or thread to sit and wait for\nanother to relinquish access to a resource (e.g. some form of mutex). In functional programming every passed argument\nis unique or immutable and the function is memoizable so we can split our work across processes much more easily with\nvirtually no deadlock since we can predict beforehand that no two functions will be fighting over write access to a\nlocation in memory.\n\n\nThere are many more advantages but I will leave this as a research exercise to you. Suffice to say, I am in no way trying\nto argue for or against functional programming as it can be incredibly effective, and has been in many scenarios, since\nits inception in the 30s via lambda calculus.\n\n\nBut one thing I think we need to be certain about: functional programming is a tool designed to help reduce human error\nand there are plenty of tools in programming designed to do this outside of the functional programming camp. The real\nworld is full of side effects and no matter how hard we try we cannot make our entire environment for development\ncompletely pure. Even our web browser is full of side effects, as you cannot predict what your end user is going to\ndo. Heck, every end user now has access to a Javascript console and the DOM through browser developer tools so at the\nend of the day nothing is 100% safe from side effects.\n\n\nBut we can try...\n\n\nPure Functional Components\n\n\nIs it possible and practical to solve the side-effect problem across an entire GUI application using functional programming\nprinciples?\n\n\nImplementation\n\n\nFor our entire GUI to be pure functional, \neach component in our view must\n:\n\n\n\n\nGet its properties passed from its parent\n\n\nNot access values outside of what is passed\n\n\nNot store any local state between renders \n\n\n\n\nOn the surface, this seems fairly reasonable, but personally I see two large problems with this approach:\n\n\n\n\nLike an idealistic political narrative, every component and developer has to be fully committed to the approach\n\n\nEvery tiny update forces potentially a ton of work that might not be necessary\n\n\n\n\nAt least in 2017, getting (1) to happen is a tall order especially if a developer wants to use a component available via\nsomething like the open-source community. Your components may be purely functional, but the ones you might depend on\nmay not be.\n\n\nRegarding (2), this might require a little more explanation.\n\n\nFunctional programming got its concepts from lambda calculus where ideally the entire world works like a mandelbrot. One\npasses in a few root arguments to a recursive set of functions that predict every leaf node render ad infinitum. In\nfunctional programming, your ideal scenario is passing the least amount of data necessary to the root call and then\ncalculate as much of the remaining data as possible through subsequent function calls. Sadly, most GUI applications do\nnot work like this.\n\n\nOne good example of doing something like this might be passing a giant flat string of user information into your render\nand subsequent functions split out the information (first name, last name, email, address). However, with web browsers\nwe run into the problem that they do not fit very well into a functional paradigm because so much of the work we have\nto do is asynchronous and in functional each callback requires running through the entire render stack... again.\nAdditionally, another reason functional is a hard fit with GUI is that in most GUIs (like a webpage) our most critical\ninformation is often needed by the leaf nodes and its ancestors cannot calculate that data from a subset. Normally we\nalready know what the users first name is from the root of the GUI... we are just trying to update \none\n leaf deep in\nthe tree.\n\n\nAs a result, what happens is that we simply invert our entire problem set into a new domain. Our components have become\n\"lightweight\" because they retain no state and are \"dumb\" in that they just do what they are told and do not try to\nmake any predictions but now all of the sensitive data for our leaf nodes in our GUI has been simply extracted into one\ngiant state store tree that holds everything.\n\n\nAnd that state store, by definition, has to be mutable at \nsome\n point... so we have eliminated side effects in our\nrender calls but we have not eliminated them completely.\n\n\nPure Functional Problems\n\n\nWhat this means practically in the most pure functional component implementation (without many optimizations)\nis that to make the tiniest change to a leaf node in our GUI we have to \nrerender (or at least recompare the output of)\nevery GUI component node\n and since every single component in our GUI has access to data it only needs so that it can\npass it to its children we have to \nmake the entire state store immutable before beginning our render so that a node\ndoes not accidentally change a store value\n.\n\n\nSo, if I want to just \nupdate a single label on the DOM\n, I have to:\n\n\n\n\nCall an action handler with a payload for the change (reducer)\n\n\nMake a clone of my entire state (might not be too expensive if we are copying by reference)\n\n\nChange the one value\n\n\nLock my state by making every value immutable\n\n\nRecall a comparison function on every single component in my GUI tree to find the one DOM node that needs changing\n\n\nCompare the shadow dom to the real DOM\n\n\nUpdate the single label or div that needs refreshing\n\n\n\n\nThe \"rerender everything\" problem is fine for video games, where every pixel on the screen has to be rerendered every\nframe anyway, but for a GUI display where you simply want to update one text element, in my opinion this is an\nunnecessary amount of work, especially in an era where power conservation is being emphasized.\n\n\nIn addition, the entire point of this new approach was eliminating side effects. While it does eliminate side effects in\nthat we might be partially guaranteed our 1000 GUI components on the screen are not retaining anything from a previous\nrender, as mentioned above our single giant state tree has to be configurable and mutable at some point before we begin\nour render, which opens us up - again - to side effects in our reducers, for example.\n\n\nUsing something like Redux, as our application scales we end up with a ton of reducers. If some rogue developer decides\nto mutate something on the state in a reducer that he should not we cannot stop him. In addition, if someone adds a\nproperty to a child deep in our GUI tree that changes with every update to the state, then every component is going to\nrerender even if we do a property comparison. If I have 50 reducers and suddenly one of my leaf nodes in my display is\nrendering something wrong, I might be able to predict which part of the store is providing the value, but I still have\nto dig through all the reducers potentially to figure out which one was causing the problem. Is this actually easier\nthan tracking down a bug in the same component because it was storing local state? It may be, but we still have not\ncompletley squashed the problems caused by human error.\n\n\nBut the problem is even more complicated. Even though I have made my state immutable, I still cannot stop a developer\nfrom passing individual properties at a component level that might be using external state to its children so making\nour entire store immutable still does not make our render predictable if a developer decides to break the functional\nprogramming \"rules\".\n\n\nAnd what if a component deep in our hierarchy does not have access to a part of the store it needs? We still have to dig\nthrough all of its parents to figure out which one we did not pass \n{...props}\n to or perhaps a component that decided it\nwas only going to pass a subset of the properties to its child.\n\n\nTo top it off, now I have a ton of extra boilerplate, especially if I want to use the container paradigm to help improve\nperformance and make my property passing more predictable. I end up creating a bunch of \"wrapper\" components that do\nvirtually nothing except pass the right props from my state store to a subset of my GUI components.\n\n\nThe functional programming paradigm's goal was to reduce side effects by removing state from components but now we have\njust shifted our entire set of problems into a new domain and now created a bunch of solutions and programming \"rules\"\nin that new domain to avoid a whole new set of bugs.\n\n\nAs always, developer diligence and some best practice principles are required whether you choose functional or\nimperative style of programming. Neither functional nor imperative programming is better, they are just different and\nan inexperienced or poor developer is guaranteed to naturally create bugs in both.\n\n\nInversion of Control (IOC)\n\n\nNote: if you are not familiar with IOC, it is highly recommended that you read up a little on the concepts before reading\nthis section. A good overview, with analogies to functional programming, can be found in the article\n\nHow to Trick OO Programmers into Loving Functional Programming\n\n\nIn traditional inversion of control, components use declarative measures to say what dependencies they need and generally\na single global builder is responsible for providing those dependencies to each component.\n\n\nThe advantage to this approach is that, unlike the functional paradigm above, each parent in your tree is not responsible\nfor providing properties to its children. As a result, you will rarely find inversion of control discussed in a purely\nfunctional programming context.\n\n\nInversion of control is used heavily in backend systems like traditional Java enterprise systems. There are tons of\nadvantages to this approach and I will leave that up to you to research.\n\n\nFor GUI systems, inversion of control can work quite well. Typically it is set up by having a single builder object\nthat is configured at application startup in the root of your GUI tree or as a singleton. As use of the application\nprogresses, new components are created and they are in some way given access to the builder or the builder is notified\nof their creation. For example, in Adobe Flash back in the day you could listen in the root GUI component using the capture\nphase of events for a signal when any new component was added to the component tree and then the builder could inspect the\nmetadata of the component and inject its dependencies. In more complex implementations, if you instruct the builder\nthat a thing has changed (e.g. the User object), then the builder has kept track of every single component in the GUI\nthat \"needs\" the User object and will provide the new user object to them so they can update themselves.\n\n\nRegardless of the exact implementation details, in IOC the builder \"wires together\" the entire application automatically\nand can notify sets of components when their dependencies have changed.\n\n\nEssentially IOC is another declarative approach outside of functional programming to accomplishing the same goal of\nproviding properties to children but in a safe environment that eliminates side effects. After all, a builder could\nchoose to provide immutable objects to the components requesting them.\n\n\nFour advantages I see of IOC over pure functional in GUI programming are:\n\n\n\n\nYou eliminate the need for a single giant state store\n\n\nYou do not have to iterate over every component in the GUI to check to see if the changed state might have\ncaused a mutation in the render\n\n\nYou are not forced to duplicate the entire application state for a tiny change\n\n\nYou do not have to create non-functioning container wrappers to subdivide your components and inject only the subset\nof the store you need\n\n\n\n\nAnother advantage of traditional IOC in OO programming is that a component can request a \ntype\n of thing. If you build\na modal window called \nNewUserModal\n that displays inputs for first name, last name, and email you could simply declare\nthat the \nNewUserModal\n has a dependency on the \nUserModel\n. If you extend \nUserModel\n with the \nSuperUserModel\n and\nthen add an instance of \nSuperUserModel\n to your builder then the builder will inject that into your \nNewUserModal\n and\nthe user modal will not care that it is a subclass. It will just use the properties it needs from the \nUserModel\n base\nclass and ignore any super features added. This is one great way of future-proofing code and creating new type extensions\nwithout breaking old GUI components.\n\n\nThat said, in GUI systems the traditional IOC with a \nsingle\n builder has huge downsides as well.\n\n\nThe biggest downside is when an application starts to use libraries or third-party components. Or if you need to have a\nsubset of your application function differently than the rest.\n\n\nTake for example a simple scenario where I want to use IOC and I want to display two Data Grids on the screen at one time.\nLet's also says that these data grids are from an external library and declare they both need a \nDataGridModel\n. How will\nmy IOC builder know \nwhich\n data grid model to inject into each one? Well this will depend on which part of the GUI tree\neach grid exists within. Perhaps one grid is in the \nUserListContainer\n section and the other is in the\n\nTransactionsListContainer\n section of your application.\n\n\nObviously a single root builder is fairly naive to what is going on. All it sees is two requests for a \nDataGridModel\n\ncome in and it does not know which grid is in which section of the application.\n\n\nIf only there was an IOC solution that worked with the DOM tree in an intelligent way to resolve these scenarios...\n\n\nIOC + Tree Structure + No Side Effects = Ringa\n\n\nWhat if there was a single Javascript library that:\n\n\n\n\nEliminated side-effects by removing as much state as possible from components \n\n\nProvided IOC and worked well with the GUI tree and resolved injections by context within that tree\n\n\nAvoided all god objects or singletons\n\n\nLet every component declare exactly what its dependencies were by type \nor\n by name\n\n\nWas able to inform only the components that need to be updated that a change has occurred in their dependencies\n\n\nEliminated almost all boilerplate code\n\n\nProvided a set of debugging tools that helped you find how all your injections are wired together\n\n\n\n\nThere is and welcome to Ringa.\n\n\nRinga: Inversion of Control Tree\n\n\nRinga is more than a typical inversion of control system. It uses the natural DOM tree to layer your dependency injections.\n\n\nEach component in your GUI tree declares its dependencies. Then during runtime, each component steps through its parents\none by one looking for the \nclosest\n dependency it can find that meets its needs. In this way I even hesitate to call it\ndependency \ninjection\n. It is a form of version control but where an algorithm is used starting at the dependent node to\nfind what it needs. In this way, by default every node in the tree will look all the way to the root node for its\ndependencies and the root node functions as a traditional builder in an IOC system.\n\n\nAnother way to think about this might be to compare it to the stack in programming. Imagine for a moment if you could\nwrite functional code like this:\n\n\nlet b = () =\n {\n  let output = findInStack('output');\n\n  console.log(output);\n}\n\nlet a = () =\n {\n  this.output = 'I'm in A!';\n\n  b();\n}\n\nlet c = () =\n {\n  this.output = 'I'm in C!';\n\n  b();\n  a();\n}\n\nc(); // I'm in C!\n     // I'm in A!\n\n\n\nIn this scenario, the b() function could exist at any depth in the stack and rather than passing properties through as\narguments, it would search up through the stack to find the first location where x is saved and then use that instead.\n\n\nThis is what Ringa does in your GUI.\n\n\nHowever, as your program grows, you can customize individual subtrees in your application by providing new models at key nodes\nin your tree. For example, you could decide that rather than having a single \nDataGridModel\n provided at the root of\nyour application, you now need to provide two of them. You provide one \nDataGridModel\n through the \nUserListContainer\n\nnode and another through the \nTransactionsListContainer\n node. By the nature of the natural container structure of your\napplication you can be very confident that no leaves outside of the subtree of the \nUserListContainer\n are going to need\nthis model. However you cannot be sure \nwhere\n in the subtree the \nDataGrid\n may end up due to UX requirements that might\nchange. So by providing the model at the deepest safe point for the UX that you can, you both ensure that you can split\nthat entire portion of your subtree into a module later if you like and also keep yourself open to large UX refactoring\nin the future. Now, the \nDataGrid\n visual component instances, regardless of where they are positioned in the entire subtree\nrelative to those two ancestors will automatically find the grid they need. You can move them around anywhere in the subtree\nand they will still just work.\n\n\nThis helps you build components and libraries too, because now you can \"break off\" entire subtrees of your display tree \neasily. Since your IOC providers are attached to the root nodes closest to the most modular part of that section of your\nDOM tree, you can break them out into new libraries easily starting at that root node. This is something that would be\nmuch harder in a functional programming or traditional IOC context.\n\n\nEach \nController\n in Ringa can be attached anywhere on your DOM tree and by default provides all of its child models,\nby Class type(s), by id, or by name to any of that nodes descendants.\n\n\nRinga: Tree Communication\n\n\nIn addition, Ringa goes far beyond dependency injection because it uses the DOM tree for all communication. Just like\ntraditional IOC with a single builder, traditionally a lot of communication frameworks (like Cairngorm in Adobe Flex or\nRedux in Javascript) use a single master bus for communication because this was easiest to understand.\n\n\nJust as each component looks through its ancestors one by one to find its dependencies, so in Ringa each component\ncommunicates by using bubbling events on the DOM. This means each component at any point in the DOM tree can both intercept\nand perform its own dependency injections and \nalso\n intercept all events (e.g. by listening to the capture or bubble\nphase of an event meant for a descendant or an ancestor).\n\n\nThis one-two punch of Ringa of treating dependency injection and intercomponent communication using the same heirarchy\nprepares your entire application to be as modular and extensible as possible.\n\n\nConclusion\n\n\nAll of the above paradigms have their place, but I hope this article sheds a little light on the inner workings of the \narchitecture of Ringa and why decisions were made as they were.\n\n\nI still feel that pure functional programming and traditional IOC have their place. However, after working with the\nconcepts of Ringa for about six years now, I personally feel it is a really solid concept that has a lot of opportunity\nto grow and I hope it can help your project be more successful.\n\n\nTo summarize with an analogy:\n\n\n\n\nFunctional programming is hierarchical management where direct bosses are responsible for giving their employees\nexactly what they need and keeping them from messing with anything other than what they are given.\n\n\nTraditional IOC is a dictatorship where a single boss is responsible for giving out what each employee needs.\n\n\nRinga is flat priority style with a hierarchical management structure where employees are empowered to request whatever\nthey need to get their job done and are responsible for going through each boss incrementally to get what they need.\nBut each boss is also empowered to redirect their employees and shield them from upper management.\n\n\n\n\nRinga is a singleton-less inversion of control system that uses the natural flow of the DOM tree to help create context\nfor both communication and dependency injection.", 
            "title": "Functional, IOC, and Ringa"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#functional-programming-inversion-of-control-and-ringa", 
            "text": "Note: the following article is about the architectural concepts of GUI and is not related to Javascript at all. This\ncould apply to any language that involves a tree of UI components.", 
            "title": "Functional Programming, Inversion of Control, and Ringa"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#topic-introduction", 
            "text": "The last several years have seen a wave of programmers pushing harder for functional programming and using a global state\nstore to manage their applications. I designed the concepts of Ringa back before any of the modern Javascript frameworks\nand libraries were around (back in 2010) and, quite honestly, before I really understood the details of functional\nprogramming.  As a result, rather than try to compare Ringa's architecture directly to the pros and cons of functional programming and\na global state store, I will just provide a walkthrough of my own understanding of functional programming and inversion\nof control in an attempt to explain how I used Ringa to tackle the same problems.", 
            "title": "Topic Introduction"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#side-effects-and-state", 
            "text": "", 
            "title": "Side-effects and State"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#defining-the-problem", 
            "text": "There are two contexts web developers are generally referring to when discussing side-effects:   Functions  Visual (GUI) Components   In programming languages, a function has a side effect when running it can mutate a variable outside of its scope. This\ncan make running a function \"unsafe\". If I am calling the function  foo()  everywhere in my code and the developer of the\nfunction decides that he is going to wipe all the DOM nodes whenever  foo()  is called, my code now no longer works. The\nsame goes for if I pass a mutable argument by reference into  foo()  and  foo()  decides to change all the properties\non the argument without my knowledge. Either way,  foo()  is unpredictable and volatile, and like Donald Trump or Brexit,\nmust be stopped.  Likewise, in GUI frameworks, a visual component could also reference or change other components or models that it should\nnot have access to. Or if a GUI component holds internal state properties that change between each call to render, then\neach time I render it, it could look differently even though I am telling it to render itself the same each time.   As a program size increases, it can become impossible for a developer to know what a specific function or visual component\nis going to do when it is called or rendered. So in both scenarios - functions or GUI components - there are massive\nbenefits to creating a pure implementation where calling the function - or rendering the visual component - is guaranteed\nto be predictable and have no side effects.  The problem, in short, is that we  want to eliminate side effects :   One solution for programming languages is to have a pure functional language like Haskell or Erlang.  The analogous solution for rendering a GUI is to mimic a functional language by developing pure components that\nhave a single render method with properties passed from the parent and no internal state.   Within React, for example, Pure components only contain a  render()  function that is guaranteed to only look at this.props  and predictably returns the exact same DOM representation for any given props - every time.", 
            "title": "Defining the Problem"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#functional-advantages", 
            "text": "There are massive advantages to the pure functional approach. For example, when using functional programming you can\nmemoize results of the calls. This allows you to cache (at the expense of memory) all previous calls and speed up future\nrenders of every component instance. If you can memoize what a component looks like with the same props, and render it\n1000 times on the display with the same props, you really only run the render function once.  Another advantage to functional is in multi-threaded or multi-core implementations. Normally, with threading we end up\nwith lots of potential for deadlock especially if multiple threads have write access to locations in memory. There are\ntons of unique ways to solve this problem, but they generally involve forcing one core or thread to sit and wait for\nanother to relinquish access to a resource (e.g. some form of mutex). In functional programming every passed argument\nis unique or immutable and the function is memoizable so we can split our work across processes much more easily with\nvirtually no deadlock since we can predict beforehand that no two functions will be fighting over write access to a\nlocation in memory.  There are many more advantages but I will leave this as a research exercise to you. Suffice to say, I am in no way trying\nto argue for or against functional programming as it can be incredibly effective, and has been in many scenarios, since\nits inception in the 30s via lambda calculus.  But one thing I think we need to be certain about: functional programming is a tool designed to help reduce human error\nand there are plenty of tools in programming designed to do this outside of the functional programming camp. The real\nworld is full of side effects and no matter how hard we try we cannot make our entire environment for development\ncompletely pure. Even our web browser is full of side effects, as you cannot predict what your end user is going to\ndo. Heck, every end user now has access to a Javascript console and the DOM through browser developer tools so at the\nend of the day nothing is 100% safe from side effects.  But we can try...", 
            "title": "Functional Advantages"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#pure-functional-components", 
            "text": "Is it possible and practical to solve the side-effect problem across an entire GUI application using functional programming\nprinciples?", 
            "title": "Pure Functional Components"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#implementation", 
            "text": "For our entire GUI to be pure functional,  each component in our view must :   Get its properties passed from its parent  Not access values outside of what is passed  Not store any local state between renders    On the surface, this seems fairly reasonable, but personally I see two large problems with this approach:   Like an idealistic political narrative, every component and developer has to be fully committed to the approach  Every tiny update forces potentially a ton of work that might not be necessary   At least in 2017, getting (1) to happen is a tall order especially if a developer wants to use a component available via\nsomething like the open-source community. Your components may be purely functional, but the ones you might depend on\nmay not be.  Regarding (2), this might require a little more explanation.  Functional programming got its concepts from lambda calculus where ideally the entire world works like a mandelbrot. One\npasses in a few root arguments to a recursive set of functions that predict every leaf node render ad infinitum. In\nfunctional programming, your ideal scenario is passing the least amount of data necessary to the root call and then\ncalculate as much of the remaining data as possible through subsequent function calls. Sadly, most GUI applications do\nnot work like this.  One good example of doing something like this might be passing a giant flat string of user information into your render\nand subsequent functions split out the information (first name, last name, email, address). However, with web browsers\nwe run into the problem that they do not fit very well into a functional paradigm because so much of the work we have\nto do is asynchronous and in functional each callback requires running through the entire render stack... again.\nAdditionally, another reason functional is a hard fit with GUI is that in most GUIs (like a webpage) our most critical\ninformation is often needed by the leaf nodes and its ancestors cannot calculate that data from a subset. Normally we\nalready know what the users first name is from the root of the GUI... we are just trying to update  one  leaf deep in\nthe tree.  As a result, what happens is that we simply invert our entire problem set into a new domain. Our components have become\n\"lightweight\" because they retain no state and are \"dumb\" in that they just do what they are told and do not try to\nmake any predictions but now all of the sensitive data for our leaf nodes in our GUI has been simply extracted into one\ngiant state store tree that holds everything.  And that state store, by definition, has to be mutable at  some  point... so we have eliminated side effects in our\nrender calls but we have not eliminated them completely.", 
            "title": "Implementation"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#pure-functional-problems", 
            "text": "What this means practically in the most pure functional component implementation (without many optimizations)\nis that to make the tiniest change to a leaf node in our GUI we have to  rerender (or at least recompare the output of)\nevery GUI component node  and since every single component in our GUI has access to data it only needs so that it can\npass it to its children we have to  make the entire state store immutable before beginning our render so that a node\ndoes not accidentally change a store value .  So, if I want to just  update a single label on the DOM , I have to:   Call an action handler with a payload for the change (reducer)  Make a clone of my entire state (might not be too expensive if we are copying by reference)  Change the one value  Lock my state by making every value immutable  Recall a comparison function on every single component in my GUI tree to find the one DOM node that needs changing  Compare the shadow dom to the real DOM  Update the single label or div that needs refreshing   The \"rerender everything\" problem is fine for video games, where every pixel on the screen has to be rerendered every\nframe anyway, but for a GUI display where you simply want to update one text element, in my opinion this is an\nunnecessary amount of work, especially in an era where power conservation is being emphasized.  In addition, the entire point of this new approach was eliminating side effects. While it does eliminate side effects in\nthat we might be partially guaranteed our 1000 GUI components on the screen are not retaining anything from a previous\nrender, as mentioned above our single giant state tree has to be configurable and mutable at some point before we begin\nour render, which opens us up - again - to side effects in our reducers, for example.  Using something like Redux, as our application scales we end up with a ton of reducers. If some rogue developer decides\nto mutate something on the state in a reducer that he should not we cannot stop him. In addition, if someone adds a\nproperty to a child deep in our GUI tree that changes with every update to the state, then every component is going to\nrerender even if we do a property comparison. If I have 50 reducers and suddenly one of my leaf nodes in my display is\nrendering something wrong, I might be able to predict which part of the store is providing the value, but I still have\nto dig through all the reducers potentially to figure out which one was causing the problem. Is this actually easier\nthan tracking down a bug in the same component because it was storing local state? It may be, but we still have not\ncompletley squashed the problems caused by human error.  But the problem is even more complicated. Even though I have made my state immutable, I still cannot stop a developer\nfrom passing individual properties at a component level that might be using external state to its children so making\nour entire store immutable still does not make our render predictable if a developer decides to break the functional\nprogramming \"rules\".  And what if a component deep in our hierarchy does not have access to a part of the store it needs? We still have to dig\nthrough all of its parents to figure out which one we did not pass  {...props}  to or perhaps a component that decided it\nwas only going to pass a subset of the properties to its child.  To top it off, now I have a ton of extra boilerplate, especially if I want to use the container paradigm to help improve\nperformance and make my property passing more predictable. I end up creating a bunch of \"wrapper\" components that do\nvirtually nothing except pass the right props from my state store to a subset of my GUI components.  The functional programming paradigm's goal was to reduce side effects by removing state from components but now we have\njust shifted our entire set of problems into a new domain and now created a bunch of solutions and programming \"rules\"\nin that new domain to avoid a whole new set of bugs.  As always, developer diligence and some best practice principles are required whether you choose functional or\nimperative style of programming. Neither functional nor imperative programming is better, they are just different and\nan inexperienced or poor developer is guaranteed to naturally create bugs in both.", 
            "title": "Pure Functional Problems"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#inversion-of-control-ioc", 
            "text": "Note: if you are not familiar with IOC, it is highly recommended that you read up a little on the concepts before reading\nthis section. A good overview, with analogies to functional programming, can be found in the article How to Trick OO Programmers into Loving Functional Programming  In traditional inversion of control, components use declarative measures to say what dependencies they need and generally\na single global builder is responsible for providing those dependencies to each component.  The advantage to this approach is that, unlike the functional paradigm above, each parent in your tree is not responsible\nfor providing properties to its children. As a result, you will rarely find inversion of control discussed in a purely\nfunctional programming context.  Inversion of control is used heavily in backend systems like traditional Java enterprise systems. There are tons of\nadvantages to this approach and I will leave that up to you to research.  For GUI systems, inversion of control can work quite well. Typically it is set up by having a single builder object\nthat is configured at application startup in the root of your GUI tree or as a singleton. As use of the application\nprogresses, new components are created and they are in some way given access to the builder or the builder is notified\nof their creation. For example, in Adobe Flash back in the day you could listen in the root GUI component using the capture\nphase of events for a signal when any new component was added to the component tree and then the builder could inspect the\nmetadata of the component and inject its dependencies. In more complex implementations, if you instruct the builder\nthat a thing has changed (e.g. the User object), then the builder has kept track of every single component in the GUI\nthat \"needs\" the User object and will provide the new user object to them so they can update themselves.  Regardless of the exact implementation details, in IOC the builder \"wires together\" the entire application automatically\nand can notify sets of components when their dependencies have changed.  Essentially IOC is another declarative approach outside of functional programming to accomplishing the same goal of\nproviding properties to children but in a safe environment that eliminates side effects. After all, a builder could\nchoose to provide immutable objects to the components requesting them.  Four advantages I see of IOC over pure functional in GUI programming are:   You eliminate the need for a single giant state store  You do not have to iterate over every component in the GUI to check to see if the changed state might have\ncaused a mutation in the render  You are not forced to duplicate the entire application state for a tiny change  You do not have to create non-functioning container wrappers to subdivide your components and inject only the subset\nof the store you need   Another advantage of traditional IOC in OO programming is that a component can request a  type  of thing. If you build\na modal window called  NewUserModal  that displays inputs for first name, last name, and email you could simply declare\nthat the  NewUserModal  has a dependency on the  UserModel . If you extend  UserModel  with the  SuperUserModel  and\nthen add an instance of  SuperUserModel  to your builder then the builder will inject that into your  NewUserModal  and\nthe user modal will not care that it is a subclass. It will just use the properties it needs from the  UserModel  base\nclass and ignore any super features added. This is one great way of future-proofing code and creating new type extensions\nwithout breaking old GUI components.  That said, in GUI systems the traditional IOC with a  single  builder has huge downsides as well.  The biggest downside is when an application starts to use libraries or third-party components. Or if you need to have a\nsubset of your application function differently than the rest.  Take for example a simple scenario where I want to use IOC and I want to display two Data Grids on the screen at one time.\nLet's also says that these data grids are from an external library and declare they both need a  DataGridModel . How will\nmy IOC builder know  which  data grid model to inject into each one? Well this will depend on which part of the GUI tree\neach grid exists within. Perhaps one grid is in the  UserListContainer  section and the other is in the TransactionsListContainer  section of your application.  Obviously a single root builder is fairly naive to what is going on. All it sees is two requests for a  DataGridModel \ncome in and it does not know which grid is in which section of the application.  If only there was an IOC solution that worked with the DOM tree in an intelligent way to resolve these scenarios...", 
            "title": "Inversion of Control (IOC)"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#ioc-tree-structure-no-side-effects-ringa", 
            "text": "What if there was a single Javascript library that:   Eliminated side-effects by removing as much state as possible from components   Provided IOC and worked well with the GUI tree and resolved injections by context within that tree  Avoided all god objects or singletons  Let every component declare exactly what its dependencies were by type  or  by name  Was able to inform only the components that need to be updated that a change has occurred in their dependencies  Eliminated almost all boilerplate code  Provided a set of debugging tools that helped you find how all your injections are wired together   There is and welcome to Ringa.", 
            "title": "IOC + Tree Structure + No Side Effects = Ringa"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#ringa-inversion-of-control-tree", 
            "text": "Ringa is more than a typical inversion of control system. It uses the natural DOM tree to layer your dependency injections.  Each component in your GUI tree declares its dependencies. Then during runtime, each component steps through its parents\none by one looking for the  closest  dependency it can find that meets its needs. In this way I even hesitate to call it\ndependency  injection . It is a form of version control but where an algorithm is used starting at the dependent node to\nfind what it needs. In this way, by default every node in the tree will look all the way to the root node for its\ndependencies and the root node functions as a traditional builder in an IOC system.  Another way to think about this might be to compare it to the stack in programming. Imagine for a moment if you could\nwrite functional code like this:  let b = () =  {\n  let output = findInStack('output');\n\n  console.log(output);\n}\n\nlet a = () =  {\n  this.output = 'I'm in A!';\n\n  b();\n}\n\nlet c = () =  {\n  this.output = 'I'm in C!';\n\n  b();\n  a();\n}\n\nc(); // I'm in C!\n     // I'm in A!  In this scenario, the b() function could exist at any depth in the stack and rather than passing properties through as\narguments, it would search up through the stack to find the first location where x is saved and then use that instead.  This is what Ringa does in your GUI.  However, as your program grows, you can customize individual subtrees in your application by providing new models at key nodes\nin your tree. For example, you could decide that rather than having a single  DataGridModel  provided at the root of\nyour application, you now need to provide two of them. You provide one  DataGridModel  through the  UserListContainer \nnode and another through the  TransactionsListContainer  node. By the nature of the natural container structure of your\napplication you can be very confident that no leaves outside of the subtree of the  UserListContainer  are going to need\nthis model. However you cannot be sure  where  in the subtree the  DataGrid  may end up due to UX requirements that might\nchange. So by providing the model at the deepest safe point for the UX that you can, you both ensure that you can split\nthat entire portion of your subtree into a module later if you like and also keep yourself open to large UX refactoring\nin the future. Now, the  DataGrid  visual component instances, regardless of where they are positioned in the entire subtree\nrelative to those two ancestors will automatically find the grid they need. You can move them around anywhere in the subtree\nand they will still just work.  This helps you build components and libraries too, because now you can \"break off\" entire subtrees of your display tree \neasily. Since your IOC providers are attached to the root nodes closest to the most modular part of that section of your\nDOM tree, you can break them out into new libraries easily starting at that root node. This is something that would be\nmuch harder in a functional programming or traditional IOC context.  Each  Controller  in Ringa can be attached anywhere on your DOM tree and by default provides all of its child models,\nby Class type(s), by id, or by name to any of that nodes descendants.", 
            "title": "Ringa: Inversion of Control Tree"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#ringa-tree-communication", 
            "text": "In addition, Ringa goes far beyond dependency injection because it uses the DOM tree for all communication. Just like\ntraditional IOC with a single builder, traditionally a lot of communication frameworks (like Cairngorm in Adobe Flex or\nRedux in Javascript) use a single master bus for communication because this was easiest to understand.  Just as each component looks through its ancestors one by one to find its dependencies, so in Ringa each component\ncommunicates by using bubbling events on the DOM. This means each component at any point in the DOM tree can both intercept\nand perform its own dependency injections and  also  intercept all events (e.g. by listening to the capture or bubble\nphase of an event meant for a descendant or an ancestor).  This one-two punch of Ringa of treating dependency injection and intercomponent communication using the same heirarchy\nprepares your entire application to be as modular and extensible as possible.", 
            "title": "Ringa: Tree Communication"
        }, 
        {
            "location": "/architecture/iocFPAndRinga/#conclusion", 
            "text": "All of the above paradigms have their place, but I hope this article sheds a little light on the inner workings of the \narchitecture of Ringa and why decisions were made as they were.  I still feel that pure functional programming and traditional IOC have their place. However, after working with the\nconcepts of Ringa for about six years now, I personally feel it is a really solid concept that has a lot of opportunity\nto grow and I hope it can help your project be more successful.  To summarize with an analogy:   Functional programming is hierarchical management where direct bosses are responsible for giving their employees\nexactly what they need and keeping them from messing with anything other than what they are given.  Traditional IOC is a dictatorship where a single boss is responsible for giving out what each employee needs.  Ringa is flat priority style with a hierarchical management structure where employees are empowered to request whatever\nthey need to get their job done and are responsible for going through each boss incrementally to get what they need.\nBut each boss is also empowered to redirect their employees and shield them from upper management.   Ringa is a singleton-less inversion of control system that uses the natural flow of the DOM tree to help create context\nfor both communication and dependency injection.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/architecture/dependencyInjection/", 
            "text": "Dependency Injection\n\n\nNote: make sure you have read and understand everything in the \nHello World Tutorial\n before proceeding.\n\n\nRinga JS currently has two types of dependency injection:\n\n\n\n\nFunction argument injection by name for Controller executors\n\n\nView \nModel\n injection through \nreact-ringa\n Plugin\n\n\n\n\n1. Function Argument Injection\n\n\nThere are several rules that are followed when performing all function injections in Ringa JS:\n\n\n\n\nFunction injection always injects by name\n\n\nOrder of arguments does not matter\n\n\nRinga JS will always warn you in the console if a property could not be found for injection\n\n\n\n\nLimitations:\n\n\n\n\nYou cannot currently use defaults (e.g. \n(f = 0) =\n {}\n) when performing injections due to the various ways that different transpilers treat this code. I spent a good 4-6 hours trying to figure out how to do this and gave up.\n\n\n\n\n1.1. Executor Event Detail Injection\n\n\nimport {Controller} from 'ringa'\n\nclass MyController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('saySomething', (message) =\n {\n      console.log(message);\n    });\n  }\n}\n\n...\n\nimport {dispatch} from 'ringa';\n\ndispatch('saySomething', {\n  message: 'I will be injected!'\n}, document);\n\n\n\nYou will notice that the property has been injected by its name \nmessage\n.\n\n\nEvery key in the detail object is available for injection in every executor.\n\n\n1.2. Executor \nModel\n Injection\n\n\nAs we have seen in 1.2, executors can request \nRingaEvent\n details be injected by their name. Executors can request \nModel\n objects be injected by name as well. \n\n\nPlease note that all Ringa JS \nModel\n instances by default have their \nname\n set to the camelcase of their class name. As a result, when\nyou create and add a \nModel\n to a \nController\n, that model can be injected by its default name. For example, if your model is named \nCarModel\n you can\nuse \naddModel\n to attach the model to your Controller and then inject it by its default camelcase name \ncarModel\n.\n\n\nimport {Controller, Model} from 'ringa'\n\nconst CarModel = Model.construct('CarModel', ['brand', 'type', 'color', 'state']);\nconst DriverModel = Model.construct('DriverModel', ['name', 'skill']);\n\nclass CarController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addModel(new CarModel());\n    this.addModel(new DriverModel('Joshua'));\n\n    this.addListener('startDriving', (carModel) =\n {\n      carModel.state = 'driving';\n    });\n\n    this.addListener('brakeSuddenly', (carModel, Joshua) =\n {\n      if (Joshua.skill === 0) {\n        carModel.state = 'crashed';\n      } else {\n        carModel.state = 'stopped';\n      }\n    });\n  }\n}\n\n\n\nIn this example, we see that \ncarModel\n and \nJoshua\n can be injected easily by either the default name or the custom name.\n\n\n1.3. Event Chaining and Injections\n\n\nIn Ringa JS, one \nController\n executor chain can trigger another. When this happens, all the injections that were available in the original dispatched event are also available in the executors responding to the secondary dispatched event:\n\n\nimport {Controller, Model, event} from 'ringa'\n\nclass ConsoleController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    // Ringa JS automatically creates ConsoleController.LOG\n    this.addListener('log', message =\n {console.log(message);});\n  }\n}\n\nclass MessageController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    // Ringa JS automatically creates MessageController.SAY_SOMETHING\n    this.addListener('saySomething', event(ConsoleController.LOG));\n  }\n}\n\n...\n\n// Assuming the above controllers have been attached to the document...\ndispatch(MessageController.SAY_SOMETHING, {\n  message: 'Woohoo, this gets passed through to ConsoleController!'\n}, document);\n\n\n\nOne huge architectural advantage of this system is that controllers can function as interfaces to other generic implementations.\n\n\nBut what if there is a name collision somewhere in the chain, like this:\n\n\nimport {Controller, Model, event} from 'ringa'\n\nclass ConsoleController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('log', (message, $ringaEvent, $lastEvent) =\n {\n      console.log(message);                       // Message 2!\n      console.log($ringaEvent.lastEvent.detail.message); // Message 1!\n      console.log($lastEvent.detail.message);            // Message 1!\n    });\n  }\n}\n\nclass MessageController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('saySomething', event(ConsoleController.LOG, {\n      message: 'Message 2!' // Uh oh, the name 'message' collides with our 'message' below!\n    }));\n  }\n}\n\n...\n\n// Assuming the above controllers have been attached to the document...\ndispatch(MessageController.SAY_SOMETHING, {\n  message: 'Message 1!'\n}, document);\n\n\n\nRinga JS always retains all contextual information even in a naming conflict. If you dispatch an event that overrides a name that was provided in the original event you can still access the original variable through either \n$ringaEvent.lastEvent\n or \n$lastEvent\n.\n\n\n1.4. Promise Injection\n\n\nEvery time you call \ndispatch()\n a \nRingaEvent\n object is created and returned. The \nRingaEvent\n object functions like a promise and you can request injections in your \nthen\n or \ncatch\n:\n\n\nimport {Controller, Model, event} from 'ringa'\n\nconst UserModel = Model.construct('UserModel', ['name']);\n\nclass UserController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addModel(new UserModel());\n\n    this.addListener('getUser', [\n      // Do some complex server call\n    ]);\n  }\n}\n\n...\n\n// userModel is injected because it exists on the handling controller\ndispatch(UserController.GET_USER, {}, document).then(userModel =\n {\n  console.log(`${userModel.name} has been successfully retrieved!`);\n});\n\n\n\n1.5. Built in Injections\n\n\nRinga JS by default provides several built-in variables that can be injected at any time:\n\n\n\n\n$controller\n: The controller that caught and is currently handling the event.\n\n\n$thread\n: The internal thread object that is currently managing the executors for the event.\n\n\n$ringaEvent\n: The original \nRingaEvent\n that was dispatched.\n\n\nevent\n: If a DOM event (like \nclick\n or \nmouseover\n) triggered the executor chain, then this would be the DOM event. Note that all DOM events that are caught by Ringa \nController\n are wrapped in a \nRingaEvent\n before the executors are run.\n\n\n$lastEvent\n: If one \nRingaEvent\n chain triggers another (e.g. by using \nevent()\n) then you can access the prior events via \n$lastEvent\n. These are chained together so if an event triggers 3 executor chains, then \n$lastEvent.lastEvent.lastEvent\n would be valid.\n\n\n$customEvent\n: Accesses the DOM \nCustomEvent\n object that is used to dispatch the \nRingaEvent\n through the DOM nodes.\n\n\n$target\n: The target DOM node that dispatched the event.\n\n\n$detail\n: The event detail object. Useful if you want to add new properties or for some reason cannot inject the properties by name.\n\n\ndone\n: Only available in a function executor. A function to call when the executor has been completed. Similar to \nMocha\n or \nJest\n unit tests.\n\n\nfail\n: Similar to done, except triggers a failure of the executor chain.\n\n\nstop\n: Useful for debugging. Stops the executor and outputs information to the console, where you can start the executor chain again.\n\n\nresume\n: Resume the executor chain.\n\n\n$lastPromiseResult\n: If \nany\n previous executor returned a promise that completed, the result will be contained here.\n\n\n$lastPromiseError\n: If \nany\n previous executor returned a promise that errored, the error will be contained here.\n\n\n\n\n1.6. Custom Injections\n\n\nCustom injection values can be added easily to the \noptions.injections\n object:\n\n\nimport {Controller, Model, event} from 'ringa'\n\nclass DudeController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.options.injections.someCustomValue = 'I just have to find a cash machine...';\n\n    this.addListener('doSomething', ...);\n  }\n}\n\n...\n\ndispatch(DudeController.DO_SOMETHING, {}, document).then(someCustomValue =\n {\n  console.log(someCustomValue);\n});\n\n\n\n1.7. Preparing for Production (Uglify)\n\n\nWhen preparing production code, your variable names will be uglified. As a result, you need to add the list of injected variable names to the blacklist for \nUglifyJS\n:\n\n\nplugins: [\n  new webpack.DefinePlugin({\n    __DEV__: false\n  }),\n  new webpack.optimize.UglifyJsPlugin({\n    sourceMap: true,\n    mangle: {\n      except: [\n        '$controller',\n        '$thread',\n        '$ringaEvent',\n        'event',\n        '$customEvent',\n        '$lastEvent',\n        '$target',\n        '$detail',\n        'done',\n        'fail',\n        '$lastPromiseResult',\n        '$lastPromiseError'\n        ...]\n    }\n  })\n]\n\n\n\nBut how do you know what they are?\n\n\nWhen in \n__DEV__: true\n mode, Ringa JS keeps track of every single variable that has been injected and builds a whilelist for you.\n\n\nTo view all the injections you need to add to the \nmangle\n property of \nUglifyJS\n, after you have run your application and all of its various executors go to the browser console:\n\n\n\n\nPlease note that because a lot of the injections that can occur in Ringa JS are dynamic, it is impossible to know before running each executor which variable names will need to avoid mangling.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#dependency-injection", 
            "text": "Note: make sure you have read and understand everything in the  Hello World Tutorial  before proceeding.  Ringa JS currently has two types of dependency injection:   Function argument injection by name for Controller executors  View  Model  injection through  react-ringa  Plugin", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#1-function-argument-injection", 
            "text": "There are several rules that are followed when performing all function injections in Ringa JS:   Function injection always injects by name  Order of arguments does not matter  Ringa JS will always warn you in the console if a property could not be found for injection   Limitations:   You cannot currently use defaults (e.g.  (f = 0) =  {} ) when performing injections due to the various ways that different transpilers treat this code. I spent a good 4-6 hours trying to figure out how to do this and gave up.", 
            "title": "1. Function Argument Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#11-executor-event-detail-injection", 
            "text": "import {Controller} from 'ringa'\n\nclass MyController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('saySomething', (message) =  {\n      console.log(message);\n    });\n  }\n}\n\n...\n\nimport {dispatch} from 'ringa';\n\ndispatch('saySomething', {\n  message: 'I will be injected!'\n}, document);  You will notice that the property has been injected by its name  message .  Every key in the detail object is available for injection in every executor.", 
            "title": "1.1. Executor Event Detail Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#12-executor-model-injection", 
            "text": "As we have seen in 1.2, executors can request  RingaEvent  details be injected by their name. Executors can request  Model  objects be injected by name as well.   Please note that all Ringa JS  Model  instances by default have their  name  set to the camelcase of their class name. As a result, when\nyou create and add a  Model  to a  Controller , that model can be injected by its default name. For example, if your model is named  CarModel  you can\nuse  addModel  to attach the model to your Controller and then inject it by its default camelcase name  carModel .  import {Controller, Model} from 'ringa'\n\nconst CarModel = Model.construct('CarModel', ['brand', 'type', 'color', 'state']);\nconst DriverModel = Model.construct('DriverModel', ['name', 'skill']);\n\nclass CarController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addModel(new CarModel());\n    this.addModel(new DriverModel('Joshua'));\n\n    this.addListener('startDriving', (carModel) =  {\n      carModel.state = 'driving';\n    });\n\n    this.addListener('brakeSuddenly', (carModel, Joshua) =  {\n      if (Joshua.skill === 0) {\n        carModel.state = 'crashed';\n      } else {\n        carModel.state = 'stopped';\n      }\n    });\n  }\n}  In this example, we see that  carModel  and  Joshua  can be injected easily by either the default name or the custom name.", 
            "title": "1.2. Executor Model Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#13-event-chaining-and-injections", 
            "text": "In Ringa JS, one  Controller  executor chain can trigger another. When this happens, all the injections that were available in the original dispatched event are also available in the executors responding to the secondary dispatched event:  import {Controller, Model, event} from 'ringa'\n\nclass ConsoleController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    // Ringa JS automatically creates ConsoleController.LOG\n    this.addListener('log', message =  {console.log(message);});\n  }\n}\n\nclass MessageController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    // Ringa JS automatically creates MessageController.SAY_SOMETHING\n    this.addListener('saySomething', event(ConsoleController.LOG));\n  }\n}\n\n...\n\n// Assuming the above controllers have been attached to the document...\ndispatch(MessageController.SAY_SOMETHING, {\n  message: 'Woohoo, this gets passed through to ConsoleController!'\n}, document);  One huge architectural advantage of this system is that controllers can function as interfaces to other generic implementations.  But what if there is a name collision somewhere in the chain, like this:  import {Controller, Model, event} from 'ringa'\n\nclass ConsoleController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('log', (message, $ringaEvent, $lastEvent) =  {\n      console.log(message);                       // Message 2!\n      console.log($ringaEvent.lastEvent.detail.message); // Message 1!\n      console.log($lastEvent.detail.message);            // Message 1!\n    });\n  }\n}\n\nclass MessageController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addListener('saySomething', event(ConsoleController.LOG, {\n      message: 'Message 2!' // Uh oh, the name 'message' collides with our 'message' below!\n    }));\n  }\n}\n\n...\n\n// Assuming the above controllers have been attached to the document...\ndispatch(MessageController.SAY_SOMETHING, {\n  message: 'Message 1!'\n}, document);  Ringa JS always retains all contextual information even in a naming conflict. If you dispatch an event that overrides a name that was provided in the original event you can still access the original variable through either  $ringaEvent.lastEvent  or  $lastEvent .", 
            "title": "1.3. Event Chaining and Injections"
        }, 
        {
            "location": "/architecture/dependencyInjection/#14-promise-injection", 
            "text": "Every time you call  dispatch()  a  RingaEvent  object is created and returned. The  RingaEvent  object functions like a promise and you can request injections in your  then  or  catch :  import {Controller, Model, event} from 'ringa'\n\nconst UserModel = Model.construct('UserModel', ['name']);\n\nclass UserController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.addModel(new UserModel());\n\n    this.addListener('getUser', [\n      // Do some complex server call\n    ]);\n  }\n}\n\n...\n\n// userModel is injected because it exists on the handling controller\ndispatch(UserController.GET_USER, {}, document).then(userModel =  {\n  console.log(`${userModel.name} has been successfully retrieved!`);\n});", 
            "title": "1.4. Promise Injection"
        }, 
        {
            "location": "/architecture/dependencyInjection/#15-built-in-injections", 
            "text": "Ringa JS by default provides several built-in variables that can be injected at any time:   $controller : The controller that caught and is currently handling the event.  $thread : The internal thread object that is currently managing the executors for the event.  $ringaEvent : The original  RingaEvent  that was dispatched.  event : If a DOM event (like  click  or  mouseover ) triggered the executor chain, then this would be the DOM event. Note that all DOM events that are caught by Ringa  Controller  are wrapped in a  RingaEvent  before the executors are run.  $lastEvent : If one  RingaEvent  chain triggers another (e.g. by using  event() ) then you can access the prior events via  $lastEvent . These are chained together so if an event triggers 3 executor chains, then  $lastEvent.lastEvent.lastEvent  would be valid.  $customEvent : Accesses the DOM  CustomEvent  object that is used to dispatch the  RingaEvent  through the DOM nodes.  $target : The target DOM node that dispatched the event.  $detail : The event detail object. Useful if you want to add new properties or for some reason cannot inject the properties by name.  done : Only available in a function executor. A function to call when the executor has been completed. Similar to  Mocha  or  Jest  unit tests.  fail : Similar to done, except triggers a failure of the executor chain.  stop : Useful for debugging. Stops the executor and outputs information to the console, where you can start the executor chain again.  resume : Resume the executor chain.  $lastPromiseResult : If  any  previous executor returned a promise that completed, the result will be contained here.  $lastPromiseError : If  any  previous executor returned a promise that errored, the error will be contained here.", 
            "title": "1.5. Built in Injections"
        }, 
        {
            "location": "/architecture/dependencyInjection/#16-custom-injections", 
            "text": "Custom injection values can be added easily to the  options.injections  object:  import {Controller, Model, event} from 'ringa'\n\nclass DudeController extends Controller {\n  constructor(name, options) {\n    super(name, options);\n\n    this.options.injections.someCustomValue = 'I just have to find a cash machine...';\n\n    this.addListener('doSomething', ...);\n  }\n}\n\n...\n\ndispatch(DudeController.DO_SOMETHING, {}, document).then(someCustomValue =  {\n  console.log(someCustomValue);\n});", 
            "title": "1.6. Custom Injections"
        }, 
        {
            "location": "/architecture/dependencyInjection/#17-preparing-for-production-uglify", 
            "text": "When preparing production code, your variable names will be uglified. As a result, you need to add the list of injected variable names to the blacklist for  UglifyJS :  plugins: [\n  new webpack.DefinePlugin({\n    __DEV__: false\n  }),\n  new webpack.optimize.UglifyJsPlugin({\n    sourceMap: true,\n    mangle: {\n      except: [\n        '$controller',\n        '$thread',\n        '$ringaEvent',\n        'event',\n        '$customEvent',\n        '$lastEvent',\n        '$target',\n        '$detail',\n        'done',\n        'fail',\n        '$lastPromiseResult',\n        '$lastPromiseError'\n        ...]\n    }\n  })\n]  But how do you know what they are?  When in  __DEV__: true  mode, Ringa JS keeps track of every single variable that has been injected and builds a whilelist for you.  To view all the injections you need to add to the  mangle  property of  UglifyJS , after you have run your application and all of its various executors go to the browser console:   Please note that because a lot of the injections that can occur in Ringa JS are dynamic, it is impossible to know before running each executor which variable names will need to avoid mangling.", 
            "title": "1.7. Preparing for Production (Uglify)"
        }, 
        {
            "location": "/architecture/events/", 
            "text": "Events\n\n\nAll communication in Ringa occurs between \nController\n instances via \nBus\n objects.\n\n\nFor busses, you have one of two options:\n\n\n1) The DOM \nCustomEvent\n bubbling event system.\n2) A recreation of the DOM bubbling event system via the Ringa \nBus\n (for server-side or custom implementations).\n\n\nInternally all events in Ringa are wrapped with the \nRingaEvent\n object, which has methods like \nthen\n and \ncatch\n\nso that events can work like \nPromises\n.\n\n\nNote: The term \nbus\n is often used in the Ringa documentation. Both a DOM node and the Ringa \nBus\n objects are valid \"bus\" objects and are treated identically within Ringa.\n \n\n\n1. Dispatching\n\n\ndispatch()\n\n\ndispatch(eventType, detail, bus, bubbles = true, cancellable = true, requireCatch = true)\n\n\n\n\n\neventType\n: a String event type\n\n\ndetail\n: the detail Object\n\n\nbus\n: a Ringa \nBus\n object or a DOM node (e.g. like \ndocument\n or a \ndiv\n)\n\n\nbubbles\n: whether to allow the event to bubble to ancestor busses (DOM nodes in browser)\n\n\ncancellable\n: whether to allow the event to be cancelled (not yet implemented)\n\n\n\n\nrequireCatch\n: show a warning in the console if the event is not caught by a Ringa \nController\n\n\nimport {dispatch} from 'ringa';\n\n\nlet ringaEvent = dispatch('doSomething', {\n  text: 'this is the event detail object, injectable via $detail'\n}, document);\n\n\n\n\n\n\nIn this example, we are using the browser \ndocument\n as the bus so any \nController\n objects listening for \n\"doSomething\"\n\nwill respond.\n\n\n2. \nthen\n and \ncatch\n\n\nRingaEvent\n objects act like promises. Goal is full implementation of the Promise API:\n\n\nimport {dispatch} from 'ringa';\n\nlet ringaEvent = dispatch('doSomething', {\n  text: 'this is the event detail object, injectable via $detail'\n}, document);\n\nringaEvent.then(() =\n {});\nringaEvent.catch(() =\n {});\n\n\n\nNote that \nthen\n and \ncatch\n fully implement the injection mechanism and you can inject any Ringa variables to the function\narguments:\n\n\nlet ringaEvent = dispatch('doSomething', {\n    text: 'Hej Ringa!'\n  }, document).then(text =\n {\n    console.log(text); // Hey Ringa!\n  });\n\n\n\n3. Debugging\n\n\nIf you set \ndebug\n to \ntrue\n in a \nRingaEvent\n detail (and you are in \n__DEV__\n mode), you can get some additional console\noutput about the events lifecycle:\n\n\nlet ringaEvent = dispatch('doSomething', {\n    debug: true\n  }, document)\n\n\n\n`", 
            "title": "Event System"
        }, 
        {
            "location": "/architecture/events/#events", 
            "text": "All communication in Ringa occurs between  Controller  instances via  Bus  objects.  For busses, you have one of two options:  1) The DOM  CustomEvent  bubbling event system.\n2) A recreation of the DOM bubbling event system via the Ringa  Bus  (for server-side or custom implementations).  Internally all events in Ringa are wrapped with the  RingaEvent  object, which has methods like  then  and  catch \nso that events can work like  Promises .  Note: The term  bus  is often used in the Ringa documentation. Both a DOM node and the Ringa  Bus  objects are valid \"bus\" objects and are treated identically within Ringa.", 
            "title": "Events"
        }, 
        {
            "location": "/architecture/events/#1-dispatching", 
            "text": "", 
            "title": "1. Dispatching"
        }, 
        {
            "location": "/architecture/events/#dispatch", 
            "text": "dispatch(eventType, detail, bus, bubbles = true, cancellable = true, requireCatch = true)   eventType : a String event type  detail : the detail Object  bus : a Ringa  Bus  object or a DOM node (e.g. like  document  or a  div )  bubbles : whether to allow the event to bubble to ancestor busses (DOM nodes in browser)  cancellable : whether to allow the event to be cancelled (not yet implemented)   requireCatch : show a warning in the console if the event is not caught by a Ringa  Controller  import {dispatch} from 'ringa';  let ringaEvent = dispatch('doSomething', {\n  text: 'this is the event detail object, injectable via $detail'\n}, document);    In this example, we are using the browser  document  as the bus so any  Controller  objects listening for  \"doSomething\" \nwill respond.", 
            "title": "dispatch()"
        }, 
        {
            "location": "/architecture/events/#2-then-and-catch", 
            "text": "RingaEvent  objects act like promises. Goal is full implementation of the Promise API:  import {dispatch} from 'ringa';\n\nlet ringaEvent = dispatch('doSomething', {\n  text: 'this is the event detail object, injectable via $detail'\n}, document);\n\nringaEvent.then(() =  {});\nringaEvent.catch(() =  {});  Note that  then  and  catch  fully implement the injection mechanism and you can inject any Ringa variables to the function\narguments:  let ringaEvent = dispatch('doSomething', {\n    text: 'Hej Ringa!'\n  }, document).then(text =  {\n    console.log(text); // Hey Ringa!\n  });", 
            "title": "2. then and catch"
        }, 
        {
            "location": "/architecture/events/#3-debugging", 
            "text": "If you set  debug  to  true  in a  RingaEvent  detail (and you are in  __DEV__  mode), you can get some additional console\noutput about the events lifecycle:  let ringaEvent = dispatch('doSomething', {\n    debug: true\n  }, document)  `", 
            "title": "3. Debugging"
        }, 
        {
            "location": "/architecture/debugging/", 
            "text": "Debugging\n\n\nUnder construction", 
            "title": "Debugging *"
        }, 
        {
            "location": "/architecture/debugging/#debugging", 
            "text": "Under construction", 
            "title": "Debugging"
        }, 
        {
            "location": "/architecture/performance/", 
            "text": "", 
            "title": "Performance"
        }, 
        {
            "location": "/architecture/buildingComponentLibraries/", 
            "text": "Building Component Libraries\n\n\nUnder construction", 
            "title": "Building Component Libraries *"
        }, 
        {
            "location": "/architecture/buildingComponentLibraries/#building-component-libraries", 
            "text": "Under construction", 
            "title": "Building Component Libraries"
        }, 
        {
            "location": "/plugins/reactRinga/", 
            "text": "react-ringa\n Plugin\n\n\n1. Overview\n\n\nThe primary purpose of the \nreact-ringa\n plugin is to assist in dependency injection of \nModel\n objects to your React Components and to intelligently rerender them when dependencies change.\n\n\n2. Dependency Injection\n\n\nWhen using React via the \nreact-ringa\n plugin, there are a couple ways that a React Component can access to (and watch) a Ringa JS \nModel\n instance.\n\n\nFirst you will want to make a \nModel\n available for injection:\n\n\n\n\nattach(component, model)\n: use when you want to directly attach a \nModel\n instance to a Component. This will make the \nModel\n \navailable\n to the Component and all its descendants for injection. This does not do the injection directly.\n\n\n\n\nRequest a \nModel\n (or its properties) to be injected into a Component's \nstate\n in one of two ways:\n\n\n\n\ndepend(component, dependencies[])\n: use when you expect an ancestor to provide a \nModel\n and need to watch its properties and have them injected. If properties are injected, \ndepend\n ensures that the \nstate\n of the React Component accurately reflects any changes in the \nModel\n.\n\n\nwatch(component, model, properties = [])\n: if you already have access to the \nModel\n instance, you can use watch instead of \ndepend()\n.\n\n\n\n\n2.1. Attach a \nModel\n to a Component\n\n\nattach(component, controllerOrModel)\n\n\nAll \nModel\n instances are attached to a React \nComponent\n via a Ringa JS \nController\n:\n\n\nattach()\n Example 1 Direct to Model\n\n\nTo attach a \nModel\n directly to a React Component and make it available to be injected to the Component and all its descendants, you can simply do:\n\n\nimport {Model} from 'ringa'\nimport {attach} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel());\n  }\n}\n\n\n\nattach()\n Example 2 Via Controller\n\n\nIf you wish to attach the \nModel\n via a \nController\n you can do so like this:\n\n\nimport {Model} from 'ringa'\nimport {attach} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass UserController extends Controller;\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    let userController = new UserController();\n\n    userController.addModel(new UserModel());\n\n    attach(this, userController);\n  }\n}\n\n\n\n2.2. Request a \nModel\n Dependency Injection from a Component\n\n\ndepend(component, dependencies[])\n\n\nThis function searches for instances that match its list of dependencies, injects them into the React \nComponent\n \nstate\n, and watches any properties on those instances for changes and intelligently refreshes the view when changes happen.\n\n\nNote that when requesting dependencies, Ringa JS is smart enough to look for the closest matching \nModel\n that matches the type you request.\n\n\nThe closest \nModel\n is defined as:\n\n\n\n\nRequest by type\n: a \nModel\n that is attached to the current Component or its nearest ancestor that is itself of the type requested or extends the type requested.\n\n\nRequest by name\n: a \nModel\n that is attached to the current Component or its nearest ancestor that has the name requested.\n\n\n\n\nNote: Ringa JS will give you a warning when in \n__DEV__: true\n mode if it encounters more than one Model that matches your requested dependency so that you can resolve this conflict if necessary.\n\n\ndepend()\n is the closest concept to binding that exists in Ringa JS. However, unlike other binding frameworks, Ringa JS provides considerable control over when updates take place and helps to ensure that there are no performance bottlenecks.\n\n\nNote that when you use \ndepend()\n the requested \nModel\n is added to the components \nstate\n by its name.\n\n\nExample 1 Request by Type\n\n\nimport {Model} from 'ringa'\nimport {attach, depend, dependency} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(UserModel, ['firstName', 'lastName']));\n  }\n\n  render() {\n    return \ndiv\n{this.state.firstName} {this.state.lastName}\n/div\n;\n  }\n}\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel());\n  }\n\n  render() {\n    return \nUser /\n;\n  }\n}\n\n\n\nExample 1 Request by name\n\n\nimport {Model} from 'ringa'\nimport {attach, depend, dependency} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency('someCustomUserModelName', ['firstName', 'lastName']));\n  }\n\n  render() {\n    return \ndiv\n{this.state.firstName} {this.state.lastName}\n/div\n;\n  }\n}\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel('someCustomUserModelName'));\n  }\n\n  render() {\n    return \nUser /\n;\n  }\n}\n\n\n\nNotes:\n\n\n\n\nIf you do not provide any dependencies, then every property on the \nModel\n is watched.\n\n\nIf your \nModel\n is structured in a tree, you can watch children models by using dot-syntax (e.g. \ndepend(this, dependency(AppModel, ['user.firstName']))\n)\n\n\nIf your \nModel\n is structured in a tree, you can watch children models and all of their properties by using star syntax (e.g. \ndepend(this, dependency(AppModel, ['user.*']))\n)\n\n\n\n\nArchitectural benefits to this approach:\n\n\n\n\nThere is no need to pass properties to children\n\n\nEach Component is responsible for determining when it needs to update itself\n\n\nBuild all your view components and wire them up after the fact\n\n\nEasy to provide custom injections for unit tests\n\n\nSplit your large application into submodules and the child modules do not need to know anything about the parent in order to request injections\n\n\nMove view components around easily without having to worry about touching ancestors\n\n\nNo singletons or god objects\n\n\n\n\n2.3. Watch a specific \nModel\n instance on a Component\n\n\nwatch(component, model, properties = [])\n\n\nIn some cases, you may already have access to a \nModel\n instance and want to immediately watch it so that the view refreshes when a property on the \nModel\n changes:\n\n\nimport {Model} from 'ringa'\nimport {watch} from 'react-ringa';\n\nconst PlaneModel = Model.construct('PlaneModel', ['altitude', 'speed']);\n\nclass Plane extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.planeModel = new PlaneModel();\n\n    watch(this, this.planeModel, ['altitude', 'speed']);\n  }\n\n  render() {\n    const {altitude, speed} = this.state;\n\n    return \ndiv\n\n      \nspan\nAltitude: {altitude}\n/span\n\n      \nspan\nSpeed: {speed}\n/span\n\n      \nbutton onClick={this.fasterAndHigher_onClickHandler}\nGo faster and higher!\n/button\n\n    \n/div\n;\n  }\n\n  fasterAndHigher_onClickHandler() {\n    this.planeModel.altitude += 10;\n    this.planeModel.speed++;\n  }\n}\n\n\n\nIn the above example, when \naltitude\n or \nspeed\n change, those properties are automatically watched and the view is refreshed.\n\n\nNote that Ringa JS is smart enough to only perform one view refresh even though two properties are being updated.\n\n\n2.4. Performance\n\n\nBy default, React does an incredibly good job of ensuring that only DOM nodes are updated that need to be. However, because React was built from the ground up to expect that parents will pass properties to their children, if you are passing all properties to children and one of those properties changes, then this will trigger a call to \nrender()\n on all of the children that see the property has changed - even if they do not themselves need to be re-rendered.\n\n\nThankfully React 16 has made a ton of improvements to ensure that the lifecycle of Component updates is top-notch. The new scheduling paradigm has made things even better.\n\n\nRinga JS naturally integrates with React because of the unique way it tells React when to rerender a Component.\n\n\nWhenever you \ndepend\n or \nwatch\n in Ringa JS and a watched property changes, the property is added to a batch of properties to be updated the next frame via \nsetState\n. As a result you could watch dozens of properties and set all of them and only one \nsetState\n would be called by Ringa.\n\n\nIn addition, because each Component is responsible for saying what \nModel\n it needs and exactly which properties should trigger an update, parent components do not need to hold the responsibility of changing properties on their children to trigger a redraw.\n\n\nWe have discovered that Ringa JS works insanely fast with React (both 15 and 16) with literally thousands of React Components and bindings on the screen at once and only takes milliseconds to do large updates.\n\n\nAll of that said, performance bottlenecks still happen. Ringa JS has a built in warnings when it encounters performance issues. In addition every step of the process from setting a property on a \nModel\n to how it updates the display can be customized for maximum leverage over your applications lifecycle.", 
            "title": "react-ringa"
        }, 
        {
            "location": "/plugins/reactRinga/#react-ringa-plugin", 
            "text": "", 
            "title": "react-ringa Plugin"
        }, 
        {
            "location": "/plugins/reactRinga/#1-overview", 
            "text": "The primary purpose of the  react-ringa  plugin is to assist in dependency injection of  Model  objects to your React Components and to intelligently rerender them when dependencies change.", 
            "title": "1. Overview"
        }, 
        {
            "location": "/plugins/reactRinga/#2-dependency-injection", 
            "text": "When using React via the  react-ringa  plugin, there are a couple ways that a React Component can access to (and watch) a Ringa JS  Model  instance.  First you will want to make a  Model  available for injection:   attach(component, model) : use when you want to directly attach a  Model  instance to a Component. This will make the  Model   available  to the Component and all its descendants for injection. This does not do the injection directly.   Request a  Model  (or its properties) to be injected into a Component's  state  in one of two ways:   depend(component, dependencies[]) : use when you expect an ancestor to provide a  Model  and need to watch its properties and have them injected. If properties are injected,  depend  ensures that the  state  of the React Component accurately reflects any changes in the  Model .  watch(component, model, properties = []) : if you already have access to the  Model  instance, you can use watch instead of  depend() .", 
            "title": "2. Dependency Injection"
        }, 
        {
            "location": "/plugins/reactRinga/#21-attach-a-model-to-a-component", 
            "text": "attach(component, controllerOrModel)  All  Model  instances are attached to a React  Component  via a Ringa JS  Controller :", 
            "title": "2.1. Attach a Model to a Component"
        }, 
        {
            "location": "/plugins/reactRinga/#attach-example-1-direct-to-model", 
            "text": "To attach a  Model  directly to a React Component and make it available to be injected to the Component and all its descendants, you can simply do:  import {Model} from 'ringa'\nimport {attach} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel());\n  }\n}", 
            "title": "attach() Example 1 Direct to Model"
        }, 
        {
            "location": "/plugins/reactRinga/#attach-example-2-via-controller", 
            "text": "If you wish to attach the  Model  via a  Controller  you can do so like this:  import {Model} from 'ringa'\nimport {attach} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass UserController extends Controller;\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    let userController = new UserController();\n\n    userController.addModel(new UserModel());\n\n    attach(this, userController);\n  }\n}", 
            "title": "attach() Example 2 Via Controller"
        }, 
        {
            "location": "/plugins/reactRinga/#22-request-a-model-dependency-injection-from-a-component", 
            "text": "depend(component, dependencies[])  This function searches for instances that match its list of dependencies, injects them into the React  Component   state , and watches any properties on those instances for changes and intelligently refreshes the view when changes happen.  Note that when requesting dependencies, Ringa JS is smart enough to look for the closest matching  Model  that matches the type you request.  The closest  Model  is defined as:   Request by type : a  Model  that is attached to the current Component or its nearest ancestor that is itself of the type requested or extends the type requested.  Request by name : a  Model  that is attached to the current Component or its nearest ancestor that has the name requested.   Note: Ringa JS will give you a warning when in  __DEV__: true  mode if it encounters more than one Model that matches your requested dependency so that you can resolve this conflict if necessary.  depend()  is the closest concept to binding that exists in Ringa JS. However, unlike other binding frameworks, Ringa JS provides considerable control over when updates take place and helps to ensure that there are no performance bottlenecks.  Note that when you use  depend()  the requested  Model  is added to the components  state  by its name.", 
            "title": "2.2. Request a Model Dependency Injection from a Component"
        }, 
        {
            "location": "/plugins/reactRinga/#example-1-request-by-type", 
            "text": "import {Model} from 'ringa'\nimport {attach, depend, dependency} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency(UserModel, ['firstName', 'lastName']));\n  }\n\n  render() {\n    return  div {this.state.firstName} {this.state.lastName} /div ;\n  }\n}\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel());\n  }\n\n  render() {\n    return  User / ;\n  }\n}", 
            "title": "Example 1 Request by Type"
        }, 
        {
            "location": "/plugins/reactRinga/#example-1-request-by-name", 
            "text": "import {Model} from 'ringa'\nimport {attach, depend, dependency} from 'react-ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName']);\n\nclass User extends React.Component {\n  constructor(props) {\n    super(props);\n\n    depend(this, dependency('someCustomUserModelName', ['firstName', 'lastName']));\n  }\n\n  render() {\n    return  div {this.state.firstName} {this.state.lastName} /div ;\n  }\n}\n\nclass UserContainer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    attach(this, new UserModel('someCustomUserModelName'));\n  }\n\n  render() {\n    return  User / ;\n  }\n}  Notes:   If you do not provide any dependencies, then every property on the  Model  is watched.  If your  Model  is structured in a tree, you can watch children models by using dot-syntax (e.g.  depend(this, dependency(AppModel, ['user.firstName'])) )  If your  Model  is structured in a tree, you can watch children models and all of their properties by using star syntax (e.g.  depend(this, dependency(AppModel, ['user.*'])) )   Architectural benefits to this approach:   There is no need to pass properties to children  Each Component is responsible for determining when it needs to update itself  Build all your view components and wire them up after the fact  Easy to provide custom injections for unit tests  Split your large application into submodules and the child modules do not need to know anything about the parent in order to request injections  Move view components around easily without having to worry about touching ancestors  No singletons or god objects", 
            "title": "Example 1 Request by name"
        }, 
        {
            "location": "/plugins/reactRinga/#23-watch-a-specific-model-instance-on-a-component", 
            "text": "watch(component, model, properties = [])  In some cases, you may already have access to a  Model  instance and want to immediately watch it so that the view refreshes when a property on the  Model  changes:  import {Model} from 'ringa'\nimport {watch} from 'react-ringa';\n\nconst PlaneModel = Model.construct('PlaneModel', ['altitude', 'speed']);\n\nclass Plane extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.planeModel = new PlaneModel();\n\n    watch(this, this.planeModel, ['altitude', 'speed']);\n  }\n\n  render() {\n    const {altitude, speed} = this.state;\n\n    return  div \n       span Altitude: {altitude} /span \n       span Speed: {speed} /span \n       button onClick={this.fasterAndHigher_onClickHandler} Go faster and higher! /button \n     /div ;\n  }\n\n  fasterAndHigher_onClickHandler() {\n    this.planeModel.altitude += 10;\n    this.planeModel.speed++;\n  }\n}  In the above example, when  altitude  or  speed  change, those properties are automatically watched and the view is refreshed.  Note that Ringa JS is smart enough to only perform one view refresh even though two properties are being updated.", 
            "title": "2.3. Watch a specific Model instance on a Component"
        }, 
        {
            "location": "/plugins/reactRinga/#24-performance", 
            "text": "By default, React does an incredibly good job of ensuring that only DOM nodes are updated that need to be. However, because React was built from the ground up to expect that parents will pass properties to their children, if you are passing all properties to children and one of those properties changes, then this will trigger a call to  render()  on all of the children that see the property has changed - even if they do not themselves need to be re-rendered.  Thankfully React 16 has made a ton of improvements to ensure that the lifecycle of Component updates is top-notch. The new scheduling paradigm has made things even better.  Ringa JS naturally integrates with React because of the unique way it tells React when to rerender a Component.  Whenever you  depend  or  watch  in Ringa JS and a watched property changes, the property is added to a batch of properties to be updated the next frame via  setState . As a result you could watch dozens of properties and set all of them and only one  setState  would be called by Ringa.  In addition, because each Component is responsible for saying what  Model  it needs and exactly which properties should trigger an update, parent components do not need to hold the responsibility of changing properties on their children to trigger a redraw.  We have discovered that Ringa JS works insanely fast with React (both 15 and 16) with literally thousands of React Components and bindings on the screen at once and only takes milliseconds to do large updates.  All of that said, performance bottlenecks still happen. Ringa JS has a built in warnings when it encounters performance issues. In addition every step of the process from setting a property on a  Model  to how it updates the display can be customized for maximum leverage over your applications lifecycle.", 
            "title": "2.4. Performance"
        }, 
        {
            "location": "/docs/", 
            "text": "Documentation Guide\n\n\nRinga Library\n\n\n\n\nRingaObject\n\n\nRingaEvent\n\n\nController\n\n\nExecutors\n\n\nModel\n\n\nModelWatcher\n\n\nBus\n\n\ndispatch()\n\n\n\n\nReact Ringa Library\n\n\n\n\nattach()\n\n\ndepend()\n\n\nwatch()\n\n\n\n\nArchitecture\n\n\n\n\nEvent System\n\n\nControllers and Green Threads\n\n\nAsynchronous Trees\n\n\nDebugging\n\n\n\n\nGlossary\n\n\nFAQ", 
            "title": "Index"
        }, 
        {
            "location": "/docs/#documentation-guide", 
            "text": "", 
            "title": "Documentation Guide"
        }, 
        {
            "location": "/docs/#ringa-library", 
            "text": "RingaObject  RingaEvent  Controller  Executors  Model  ModelWatcher  Bus  dispatch()", 
            "title": "Ringa Library"
        }, 
        {
            "location": "/docs/#react-ringa-library", 
            "text": "attach()  depend()  watch()", 
            "title": "React Ringa Library"
        }, 
        {
            "location": "/docs/#architecture", 
            "text": "Event System  Controllers and Green Threads  Asynchronous Trees  Debugging", 
            "title": "Architecture"
        }, 
        {
            "location": "/docs/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/docs/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/docs/ringaObject/", 
            "text": "RingaObject\n\n\nUnder construction", 
            "title": "RingaObject *"
        }, 
        {
            "location": "/docs/ringaObject/#ringaobject", 
            "text": "Under construction", 
            "title": "RingaObject"
        }, 
        {
            "location": "/docs/ringaEvent/", 
            "text": "RingaEvent\n\n\nUnder construction", 
            "title": "RingaEvent *"
        }, 
        {
            "location": "/docs/ringaEvent/#ringaevent", 
            "text": "Under construction", 
            "title": "RingaEvent"
        }, 
        {
            "location": "/docs/model/", 
            "text": "Model\n\n\n\n\nExtends \nBus\n\n\n\n\nExtends \nRingaObject\n\n\nimport {Model} from 'ringa';\n\n\n\n\n\n\nThe Ringa \nModel\n class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:\n\n\nIt provides:\n\n\n\n\nProperty management\n\n\nProperty watching\n\n\nBuilt in tree structure (optional)\n\n\nCloning (recursive)\n\n\nSerialization / deserialization (recursive)\n\n\nTrie-based indexing for search (recursive)\n\n\n\n\nExample \nUserModel\n\n\nThe following model will be used as an example throughout this document:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}\n\n\n\nIn this example, the \nUserModel\n is configured with three properties that by default:\n\n\n\n\nCan be watched for changes\n\n\nWill be included when serializing / deserializing\n\n\nWill be cloned if \nclone()\n is called\n\n\n\n\n1. Construction\n\n\nModel(name, values)\n\n\n\nThe Ringa \nModel\n constructor takes in an optional \nname\n string and optional \nvalues\n object. If the first property is an \nObject\n then it is assumed to be the \nvalues\n object.\n\n\nEvery new Ringa \nModel\n instance has the following base properties:\n\n\n\n\nid\n: inherited from \nRingaObject\n, a unique identifier for this model. A console warning will be issued if two \nRingaObjects\n contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default \nid\n is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.\n\n\nname\n: a human-readable name for the model. It is assumed that more than one model may have the same name. By default the \nname\n property is the Model class Constructor name in camelcase.\n\n\n_values\n: passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the \n_values\n property, not \nvalues\n since they are to be treated as protected members.\n\n\n\n\nUsing the example \nUserModel\n class above we could do the following:\n\n\nlet userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);\n\n\n\nOutput:\n\n\nid: UserModel1\nname: userModel\n_values: undefined\n\n\n\nThe only way to set the \nid\n property through the constructor is to use the \nvalues\n argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:\n\n\nlet userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);\n\n\n\nOutput:\n\n\nid: someCustomId\n_values: {id: 'someCustomId'}\n\n\n\nIf you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the \nvalues\n object as well:\n\n\nlet me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});\n\n\n\n1.1. \nModel.construct\n convenience syntax\n\n\nModel.construct(className, propertyArray)\n\n\n\nWhen building smaller models, a convenience method is provided which allows you to construct a \nclass\n from an array of properties.\n\n\nTo construct our \nUserModel\n class above we could do:\n\n\nimport {Model} from 'ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName', 'email']);\n\n\n\n1.2. Properties\n\n\nYou add properties to a Model with the \naddProperty\n method:\n\n\naddProperty(name, defaultValue, options);\n\n\n\n\n\nname\n: the name of the property.\n\n\ndefaultValue\n: the default value of the property.\n\n\noptions\n: a variety of options on how the property works. Discussed in the following sections.\n\n\n\n\n1.2.1. Property Names\n\n\naddProperty\n automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);\n\n\n\nOutput:\n\n\nto be or not to be\n\n\n\nNode: a future version of Ringa should attach the getter / setter for properties to the internal \nprototype\n for performance if possible.\n\n\n1.2.2. Property Defaults\n\n\nYou can specify default values for \nModel\n properties easily:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}\n\n\n\nAll properties in the \nModel\n default to \nundefined\n. In this case, we are saying the altitude should start, as it should, at \n0\n.\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.altitude);\n\n\n\nOutput:\n\n\n0\n\n\n\n1.2.3. Property Options\n\n\nThe third parameter to \naddProperty\n is an optional options \nObject\n:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}\n\n\n\nAll property options can be accessed through the \npropertyOptions\n dictionary:\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);\n\n\n\nOutput:\n\n\nThis is the altitude of the airplane.\n\n\n\nBe careful! If you accidentally pass the property options as the second parameter to \naddProperty\n they will be treated as the default value.\n\n\nNote: the following propertyOptions have special functions in Ringa and will be discussed further in the following docs:\n\n\n\n\ndescriptor\n\n\nsetParentModel\n\n\nautowatch\n\n\ndoNotNotify\n\n\nclone\n\n\ntype\n\n\nserialize\n\n\nget\n\n\nset\n\n\n\n\n1.2.4. Property Getters / Setters\n\n\nBy default, Ringa uses \nObject.defineProperty\n every time you call \naddProperty()\n to create a custom getter / setter on your model.\n\n\nHowever, you can override this quite easily:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =\n {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =\n {\n        return this._address;\n      }\n    });\n  }\n}\n\n\n\nNote: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!\n\n\n1.3. Watching\n\n\nModel's can be watched for property value changes or even custom signals.\n\n\nNote: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.\n\n\nUsing the Example Class \nUserModel\n defined at the beginning of this page, we could do the following:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';\n\n\n\nThe console will now output:\n\n\nA property has changed 'firstName': Saajan\n\n\n\n1.4. Watch Until\n\n\nModel's can be watched until a condition is met. One use case might be if you have an authorization model with a flag for being logged in. Your view could \nwatchUntil\n the user is logged in before continuing:\n\n\n\n\n\n\nwatchUntil(condition, handler, autoUnwatch = true)\n\n\nclass AuthModel = Model.construct('AuthModel', ['loggedIn']);\n\n\n...\n\n\nlet authModel = new AuthModel(); //\n\n\nauthModel.watchUntil(authModel =\n authModel.loggedIn, signal =\n {\n  console.log(\nThe user has logged in!\n);\n}, true);\n\n\n\n\n\n\nInternally the model watches all of its dispatched signals and reruns the condition check function every time. When it is truthy, then the handler is called.\n\n\nIf you set \nautoUnwatch\n to true, then the handler will only be called the first time the condition is met. If \nautoUnwatch\n is false, then the handler function will be called every time the condition is met.\n\n\n2. Advanced\n\n\nWhile all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.\n\n\n2.1. Cloning\n\n\nRinga \nModels\n can easily be cloned:\n\n\nlet userModel = new UserModel();\n\nlet clonee = userModel.clone();\n\n\n\nIn some cases you may not want to clone the \nid\n and instead want the cloned object to grab a new unique identifier:\n\n\nlet clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);\n\n\n\nOutput:\n\n\nUserModel2\n\n\n\nNote: in 2.3 we will explain how Ringa models can be structured like a tree. The \nclone()\n method is recursive on all descendants.\n\n\n2.2. Serialization\n\n\nEvery Ringa \nModel\n has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a \nModel\n tree (see section 2.3).\n\n\nBy default, only properties that have been added with \naddProperty\n are serialized or deserialized. \n\n\n2.2.1. Serializing\n\n\nTo serialize a Ringa \nModel\n:\n\n\nlet pojo = myModel.serialize();\n\n\n\nThere are lots of options for serializing Ringa models:\n\n\n\n\nOverride the \nserializeId\n getter on any \nModel\n to customize the \nid\n property for serialization.\n\n\nImplement the \nserializeProperties\n getter on any \nModel\n to return an Array of properties to be serialized for that \nModel\n.\n\n\n\n\nFor example:\n\n\nclass MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());\n\n\n\nOutput\n\n\n{\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}\n\n\n\n2.2.2. Deserializing\n\n\nBasic deserialization is easy. Assuming the \nUserModel\n example used at the beginning of this page:\n\n\nlet pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});\n\n\n\nModel.deserialize\n will instantiate a new \nUserModel\n instance and populate each of its properties with values from the POJO (if they exist).\n\n\nFor simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.\n\n\nThis can be done in several ways:\n\n\n\n\nProvide a \ntype\n option for the root model\n\n\nSet \ntype\n on the property option (for properties)\n\n\nProvide a \nmodelMapper\n \nFunction\n to the deserialize options.\n\n\n\n\n2.2.2.1. Deserializing: \ntype\n option\n\n\nAs shown above, you can provide a \ntype\n property to the deserialize options:\n\n\nlet myModel = Model.deserialize(pojo, {\n  type: MyModel\n});\n\n\n\nNote that the type provided must extend \nModel\n.\n\n\n2.2.2.2. Deserializing: \ntype\n property option\n\n\nFor individual properties, you can specify the type when calling \naddProperty\n (including Arrays) and deserialization will instantiate a new \nModel\n of that type and deserialize into it:\n\n\nclass FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});\n\n\n\nIn this case, three instances of \nFamilyTreeNode\n will be constructed, and two of them will exist inside of the \nchildren\n property of the parent node.\n\n\n2.2.2.3. Deserializing: \nmodelMapper\n option\n\n\nIn some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.\n\n\nFor this situation, you can use the \nmodelMapper\n \nFunction\n option:\n\n\nclass TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =\n {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});\n\n\n\nIn this example, if \nsomePojo\n has a property named \ntext\n then the deserializer will make a new \nTextModel\n. If it has a property named \nnumber\n then the deserializer will\nmake a \nNumberModel\n.\n\n\nNote: the \nmodelMapper\n is passed recursively in the same options object to all descendants that are deserialized as well.\n\n\n2.3. Trees\n\n\nRinga Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.\n\n\nIn addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.\n\n\n2.3.1. Autowatching and linking child \nModels\n\n\nEvery \nModel\n object watches each property for changes and if a property is set to another \nModel\n object then an internal tree structure is automatically created:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);\n\n\n\nOutput:\n\n\nParent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}\n\n\n\nIn addition to watching their properties and linking to their child \nModels\n, every \nModel\n by default watches every single child \nModel\n for property changes and dispatches a dot-notation signal when any descendant has a change:\n\n\n...\nparent.watch(signal =\n console.log);\n\nchild.text = 'Hello World';\n\n\n\nOutput:\n\n\nchild.text\n\n\n\nThe purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.\n\n\nFor example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.\n\n\n2.3.2. Watching child \nModels\n in Arrays or Objects\n\n\nNote that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call \naddModelChild\n:\n\n\nclass TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);\n\n\n\nThe first argument to \naddModelChild\n is the property that the parent can find that child within.\n\n\nThe reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.\n\n\n2.4. Notifications / \nnotify()\n\n\nBy default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.\n\n\nuser.watch(signal =\n console.log);\n\nuser.firstName = 'Josh');\n\n\n\nOutput:\n\n\nfirstName\n\n\n\nBut if the property does not change in value, then no signal is dispatched:\n\n\n// Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';\n\n\n\nThe handler method for a notification has the following signature:\n\n\nmyModel.watch((signal, signaler, value, descriptor) =\n {});\n\n\n\n\n\nsignal\n: the String signal (e.g. \n'firstName'\n). Will match the property name that has changed by default.\n\n\nsignaler\n: the \nModel\n that dispatched the signal. Useful in Model trees.\n\n\nvalue\n: the value of the property that changed (if associated with a property).\n\n\ndescriptor\n: a plain-text description of the signal (intended for use with a history feature).\n\n\n\n\n2.4.1. Custom Notifications\n\n\nOne cool feature of the Ringa \nModel\n is that you can notify your own custom signals:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');\n\n\n\n2.4.2. Turning off Notifications\n\n\nFor the sake of performance, you can turn off notifications by using the property option \ndoNotNotify\n:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');\n\n\n\nIn the above example, we notify a special event when either the \nfirstName\n or \nlastName\n has changed. This structure keeps the properties\n\nfirstName\n and \nlastName\n in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.\n\n\nAlso note that the property \nfullName\n - which may be useful in your view - is not included in the serialization / deserialization or cloning.\n\n\nThis is the standard way that I recommend implementing aggregate properties. \n\n\n2.5. Aggregate Properties\n\n\nA lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.\n\n\nUnfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:\n\n\n\n\nBindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.\n\n\nIncluding complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.\n\n\n\n\nMy goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.\n\n\n2.6. Watching property changes with \nonChange\n\n\nIf you want to do complex operations, you can do so like this:\n\n\nimport {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =\n {\n        this.notify('items');\n      }\n    });\n  }\n}\n\n\n\nNote: \nonChange\n only gets called if the value of the property \nfilter\n above actually changes to a new value.\n\n\nNow, when \nfilter\n changes, an \nitems\n signal will be dispatched:\n\n\nlet collection = new Collection();\n\ncollection.watch(signal =\n {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =\n value !== 2;\n\n\n\nOutput:\n\n\n1, 3\n\n\n\nThis notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.\n\n\n2.7 Indexing (Trie) and the \nindex\n option for search\n\n\nThe Ringa \nModel\n object allows you to index your models (recursively) using a fast-lookup \nTrie search\n. This is especially useful for type-ahead\nsearches:\n\n\nclass TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeply nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');\n\n\n\nIn this example, the call to \nindex()\n builds a new Trie internal to the root \ntree\n model. It indexes every single property that has been added with \nindex\n set to true.\n\n\nThe index method has the following signature:\n\n\nindex(recurse = false, trieSearchOptions = {}, trieSearch = undefined)\n\n\n\n\n\nrecurse\n: whether to recurse into child models and their indexed properties.\n\n\ntrieSearchOptions\n: these options will be passed into the Trie search. See the \ndocumentation\n for details.\n\n\ntrieSearch\n: if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.\n\n\n\n\nIndexing is not performed automatically, you must call \nindex()\n yourself. Also please do not call \nindex()\n more often than is necessary as building the indexing structure\nis time-intensive on large model trees.\n\n\nNote: the \naddIndexedPropery()\n method can be used instead of \naddProperty(name, {index:true})\n.", 
            "title": "Model"
        }, 
        {
            "location": "/docs/model/#model", 
            "text": "Extends  Bus   Extends  RingaObject  import {Model} from 'ringa';    The Ringa  Model  class is an optional, but core part of the framework that is a hybrid between a traditional view and data model:  It provides:   Property management  Property watching  Built in tree structure (optional)  Cloning (recursive)  Serialization / deserialization (recursive)  Trie-based indexing for search (recursive)", 
            "title": "Model"
        }, 
        {
            "location": "/docs/model/#example-usermodel", 
            "text": "The following model will be used as an example throughout this document:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}  In this example, the  UserModel  is configured with three properties that by default:   Can be watched for changes  Will be included when serializing / deserializing  Will be cloned if  clone()  is called", 
            "title": "Example UserModel"
        }, 
        {
            "location": "/docs/model/#1-construction", 
            "text": "Model(name, values)  The Ringa  Model  constructor takes in an optional  name  string and optional  values  object. If the first property is an  Object  then it is assumed to be the  values  object.  Every new Ringa  Model  instance has the following base properties:   id : inherited from  RingaObject , a unique identifier for this model. A console warning will be issued if two  RingaObjects  contain the same id so try not to reuse these (although it is necessary in some cases due to cloning). By default  id  is the Model class Constructor name followed by a number that is the number of Models that have been created so far for this type.  name : a human-readable name for the model. It is assumed that more than one model may have the same name. By default the  name  property is the Model class Constructor name in camelcase.  _values : passed in to the constructor, these are optional defaults for each property. Note that the values are stored in the  _values  property, not  values  since they are to be treated as protected members.   Using the example  UserModel  class above we could do the following:  let userModel = new UserModel();\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`name: ${userModel.name}`);\nconsole.log(`_values: ${userModel._values}`);  Output:  id: UserModel1\nname: userModel\n_values: undefined  The only way to set the  id  property through the constructor is to use the  values  argument. The reason for this is that often you want to instantiate a model from a POJO that contains the id:  let userModel = new UserModel({\n  id: 'someCustomId'\n});\n\nconsole.log(`id: ${userModel.id}`);\nconsole.log(`_values:`, userModel._values);  Output:  id: someCustomId\n_values: {id: 'someCustomId'}  If you desire to have your properties initialized immediately with different values than the Class defaults, you can provide those properties through the  values  object as well:  let me = new UserModel('joshuaJung', {\n  firstName: \"Joshua\",\n  lastName: \"Jung\"\n});", 
            "title": "1. Construction"
        }, 
        {
            "location": "/docs/model/#11-modelconstruct-convenience-syntax", 
            "text": "Model.construct(className, propertyArray)  When building smaller models, a convenience method is provided which allows you to construct a  class  from an array of properties.  To construct our  UserModel  class above we could do:  import {Model} from 'ringa';\n\nconst UserModel = Model.construct('UserModel', ['firstName', 'lastName', 'email']);", 
            "title": "1.1. Model.construct convenience syntax"
        }, 
        {
            "location": "/docs/model/#12-properties", 
            "text": "You add properties to a Model with the  addProperty  method:  addProperty(name, defaultValue, options);   name : the name of the property.  defaultValue : the default value of the property.  options : a variety of options on how the property works. Discussed in the following sections.", 
            "title": "1.2. Properties"
        }, 
        {
            "location": "/docs/model/#121-property-names", 
            "text": "addProperty  automatically constructs a getter / setter on your Model instance and internally stores the value of the property in the underscored name:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('someProperty');\n  }\n}\n...\nlet myModel = new MyModel();\nmyModel.someProperty = 'to be or not to be';\n\nconsole.log(myModel._someProperty);  Output:  to be or not to be  Node: a future version of Ringa should attach the getter / setter for properties to the internal  prototype  for performance if possible.", 
            "title": "1.2.1. Property Names"
        }, 
        {
            "location": "/docs/model/#122-property-defaults", 
            "text": "You can specify default values for  Model  properties easily:  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}  All properties in the  Model  default to  undefined . In this case, we are saying the altitude should start, as it should, at  0 .  let airplane = new Airplane();\n\nconsole.log(airplane.altitude);  Output:  0", 
            "title": "1.2.2. Property Defaults"
        }, 
        {
            "location": "/docs/model/#123-property-options", 
            "text": "The third parameter to  addProperty  is an optional options  Object :  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}  All property options can be accessed through the  propertyOptions  dictionary:  let airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);  Output:  This is the altitude of the airplane.  Be careful! If you accidentally pass the property options as the second parameter to  addProperty  they will be treated as the default value.  Note: the following propertyOptions have special functions in Ringa and will be discussed further in the following docs:   descriptor  setParentModel  autowatch  doNotNotify  clone  type  serialize  get  set", 
            "title": "1.2.3. Property Options"
        }, 
        {
            "location": "/docs/model/#124-property-getters-setters", 
            "text": "By default, Ringa uses  Object.defineProperty  every time you call  addProperty()  to create a custom getter / setter on your model.  However, you can override this quite easily:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =  {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =  {\n        return this._address;\n      }\n    });\n  }\n}  Note: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!", 
            "title": "1.2.4. Property Getters / Setters"
        }, 
        {
            "location": "/docs/model/#13-watching", 
            "text": "Model's can be watched for property value changes or even custom signals.  Note: signals are similar to lightweight events but are not the same! Signals are only a string and do not contain a detail object. In addition signals are automatically dispatched through the ancestors of a model so that parent models can listen when properties of their children change.  Using the Example Class  UserModel  defined at the beginning of this page, we could do the following:  let user = new UserModel();\n\nuser.watch(signal =  {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';  The console will now output:  A property has changed 'firstName': Saajan", 
            "title": "1.3. Watching"
        }, 
        {
            "location": "/docs/model/#14-watch-until", 
            "text": "Model's can be watched until a condition is met. One use case might be if you have an authorization model with a flag for being logged in. Your view could  watchUntil  the user is logged in before continuing:    watchUntil(condition, handler, autoUnwatch = true)  class AuthModel = Model.construct('AuthModel', ['loggedIn']);  ...  let authModel = new AuthModel(); //  authModel.watchUntil(authModel =  authModel.loggedIn, signal =  {\n  console.log( The user has logged in! );\n}, true);    Internally the model watches all of its dispatched signals and reruns the condition check function every time. When it is truthy, then the handler is called.  If you set  autoUnwatch  to true, then the handler will only be called the first time the condition is met. If  autoUnwatch  is false, then the handler function will be called every time the condition is met.", 
            "title": "1.4. Watch Until"
        }, 
        {
            "location": "/docs/model/#2-advanced", 
            "text": "While all the following features are optional, they are all designed to work together seamlessly to serve every need you could have for a Model. For the best results, I recommend reading on each of the following features to get the most mileage and reuse from your Ringa models.", 
            "title": "2. Advanced"
        }, 
        {
            "location": "/docs/model/#21-cloning", 
            "text": "Ringa  Models  can easily be cloned:  let userModel = new UserModel();\n\nlet clonee = userModel.clone();  In some cases you may not want to clone the  id  and instead want the cloned object to grab a new unique identifier:  let clonee = userModel.clone({\n  cloneId: false\n});\n\nconsole.log(clonee.id);  Output:  UserModel2  Note: in 2.3 we will explain how Ringa models can be structured like a tree. The  clone()  method is recursive on all descendants.", 
            "title": "2.1. Cloning"
        }, 
        {
            "location": "/docs/model/#22-serialization", 
            "text": "Every Ringa  Model  has highly customizable built-in serialization and deserialization. By default both serialization and deserialization are recursive in a  Model  tree (see section 2.3).  By default, only properties that have been added with  addProperty  are serialized or deserialized.", 
            "title": "2.2. Serialization"
        }, 
        {
            "location": "/docs/model/#221-serializing", 
            "text": "To serialize a Ringa  Model :  let pojo = myModel.serialize();  There are lots of options for serializing Ringa models:   Override the  serializeId  getter on any  Model  to customize the  id  property for serialization.  Implement the  serializeProperties  getter on any  Model  to return an Array of properties to be serialized for that  Model .   For example:  class MyModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', 'hello world');\n    this.addProperty('hiddenText', 'we refuse to be serialized');\n  }\n\n  get serializeId() {\n    return this.id + '_serialized';\n  }\n\n  get serializeProperties() {\n    return ['text']; // Not necessary to include id\n  }\n}\n...\nconsole.log(new MyModel().serialize());  Output  {\n  \"id\": \"MyModel1_serialized\",\n  \"text\": \"hello world\"\n}", 
            "title": "2.2.1. Serializing"
        }, 
        {
            "location": "/docs/model/#222-deserializing", 
            "text": "Basic deserialization is easy. Assuming the  UserModel  example used at the beginning of this page:  let pojo = {\n  id: \"12345678\",\n  firstName: \"Joseph\",\n  lastName: \"Williams\",\n  email: \"jwilliams@somewhere.com\"\n};\n\nlet userModel = Model.deserialize(pojo, {\n  type: UserModel\n});  Model.deserialize  will instantiate a new  UserModel  instance and populate each of its properties with values from the POJO (if they exist).  For simple cases this is sufficient. However, with trees of models, deserialization can be a lot more complicated. Since the serialized JSON object does not include information on what type of Javascript model it should be serialized back into, you need\nto provide the information yourself.  This can be done in several ways:   Provide a  type  option for the root model  Set  type  on the property option (for properties)  Provide a  modelMapper   Function  to the deserialize options.", 
            "title": "2.2.2. Deserializing"
        }, 
        {
            "location": "/docs/model/#2221-deserializing-type-option", 
            "text": "As shown above, you can provide a  type  property to the deserialize options:  let myModel = Model.deserialize(pojo, {\n  type: MyModel\n});  Note that the type provided must extend  Model .", 
            "title": "2.2.2.1. Deserializing: type option"
        }, 
        {
            "location": "/docs/model/#2222-deserializing-type-property-option", 
            "text": "For individual properties, you can specify the type when calling  addProperty  (including Arrays) and deserialization will instantiate a new  Model  of that type and deserialize into it:  class FamilyTreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('quote');\n\n    this.addProperty('children', undefined, {\n      type: FamilyTreeNode\n    });\n  }\n}\n...\nlet pojo = {\n  quote: \"I'm a father of two children!\",\n  children: [{\n    quote: \"I hate dad jokes.\"\n  }, {\n    quote: \"I, also, hate dad jokes.\"\n  }]\n};\n\nlet myModel = Model.deserialize(pojo, {\n  type: FamilyTreeNode\n});  In this case, three instances of  FamilyTreeNode  will be constructed, and two of them will exist inside of the  children  property of the parent node.", 
            "title": "2.2.2.2. Deserializing: type property option"
        }, 
        {
            "location": "/docs/model/#2223-deserializing-modelmapper-option", 
            "text": "In some cases, you may have a large tree of models and you are not sure beforehand what the types passed in will be. As a result you may\nneed to inspect the JSON object for custom indicators to determine its type.  For this situation, you can use the  modelMapper   Function  option:  class TextModel {...};\nclass NumberModel {...};\n\nlet modelMapper = (pojo, options) =  {\n  if (pojo.hasOwnProperty('text') {\n    return TextModel;\n  } else if (pojo.hasOwnProperty('number') {\n    return NumberModel;\n  }\n};\n\nlet somePojo = {...};\nlet myModel = Model.deserialize(somePojo, {modelMapper});  In this example, if  somePojo  has a property named  text  then the deserializer will make a new  TextModel . If it has a property named  number  then the deserializer will\nmake a  NumberModel .  Note: the  modelMapper  is passed recursively in the same options object to all descendants that are deserialized as well.", 
            "title": "2.2.2.3. Deserializing: modelMapper option"
        }, 
        {
            "location": "/docs/model/#23-trees", 
            "text": "Ringa Models are designed to be linked together in tree structures to make monitoring changes in a large collection of models easier.  In addition, this structure allows you to serialize, deserialize, index, and clone large recursive model structures with ease.", 
            "title": "2.3. Trees"
        }, 
        {
            "location": "/docs/model/#231-autowatching-and-linking-child-models", 
            "text": "Every  Model  object watches each property for changes and if a property is set to another  Model  object then an internal tree structure is automatically created:  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('child');\n    this.addProperty('text');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.child = child;\n\nconsole.log('Parent is:', child.parentModel.name);\nconsole.log('Children are:', parent.childIdToRef);  Output:  Parent is: parent\nChildren are:\n{\n  TreeNode2: TreeNode\n}  In addition to watching their properties and linking to their child  Models , every  Model  by default watches every single child  Model  for property changes and dispatches a dot-notation signal when any descendant has a change:  ...\nparent.watch(signal =  console.log);\n\nchild.text = 'Hello World';  Output:  child.text  The purpose of this structure is so that you can create incredibly complex model trees (like an intricate layered form) and listen for changes from any node in the entire tree and respond to the change.  For example, imagine a complex Form with groups and nodes. If you watch the root node, anytime a property anywhere in the tree changes at any node, you could trigger a validation method or an auto-save to the database without having to explicitly watch every single node in the tree or even know the size of the tree.", 
            "title": "2.3.1. Autowatching and linking child Models"
        }, 
        {
            "location": "/docs/model/#232-watching-child-models-in-arrays-or-objects", 
            "text": "Note that for Arrays or Objects, in the current version you will need to manually link children to their parents. To do so you call  addModelChild :  class TreeNode extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('children');\n  }\n}\n\n...\n\nlet parent = new TreeNode('parent');    \nlet child = new TreeNode();\n\nparent.children = [child];\n\nparent.addModelChild('children', child);  The first argument to  addModelChild  is the property that the parent can find that child within.  The reason I left this to you as a manual exercise is so that no loops over children are done without your knowledge.", 
            "title": "2.3.2. Watching child Models in Arrays or Objects"
        }, 
        {
            "location": "/docs/model/#24-notifications-notify", 
            "text": "By default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.  user.watch(signal =  console.log);\n\nuser.firstName = 'Josh');  Output:  firstName  But if the property does not change in value, then no signal is dispatched:  // Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';  The handler method for a notification has the following signature:  myModel.watch((signal, signaler, value, descriptor) =  {});   signal : the String signal (e.g.  'firstName' ). Will match the property name that has changed by default.  signaler : the  Model  that dispatched the signal. Useful in Model trees.  value : the value of the property that changed (if associated with a property).  descriptor : a plain-text description of the signal (intended for use with a history feature).", 
            "title": "2.4. Notifications / notify()"
        }, 
        {
            "location": "/docs/model/#241-custom-notifications", 
            "text": "One cool feature of the Ringa  Model  is that you can notify your own custom signals:  let user = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');", 
            "title": "2.4.1. Custom Notifications"
        }, 
        {
            "location": "/docs/model/#242-turning-off-notifications", 
            "text": "For the sake of performance, you can turn off notifications by using the property option  doNotNotify :  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');  In the above example, we notify a special event when either the  firstName  or  lastName  has changed. This structure keeps the properties firstName  and  lastName  in the serialization, indexing, and cloning while reducing the overhead of notifications for each one which is especially noticeable\nin deeply nested trees of Models.  Also note that the property  fullName  - which may be useful in your view - is not included in the serialization / deserialization or cloning.  This is the standard way that I recommend implementing aggregate properties.", 
            "title": "2.4.2. Turning off Notifications"
        }, 
        {
            "location": "/docs/model/#25-aggregate-properties", 
            "text": "A lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.  Unfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:   Bindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.  Including complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.   My goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.", 
            "title": "2.5. Aggregate Properties"
        }, 
        {
            "location": "/docs/model/#26-watching-property-changes-with-onchange", 
            "text": "If you want to do complex operations, you can do so like this:  import {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =  {\n        this.notify('items');\n      }\n    });\n  }\n}  Note:  onChange  only gets called if the value of the property  filter  above actually changes to a new value.  Now, when  filter  changes, an  items  signal will be dispatched:  let collection = new Collection();\n\ncollection.watch(signal =  {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =  value !== 2;  Output:  1, 3  This notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.", 
            "title": "2.6. Watching property changes with onChange"
        }, 
        {
            "location": "/docs/model/#27-indexing-trie-and-the-index-option-for-search", 
            "text": "The Ringa  Model  object allows you to index your models (recursively) using a fast-lookup  Trie search . This is especially useful for type-ahead\nsearches:  class TextModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('text', {index: true});\n\n    this.addProperty('children', {type: TextModel});\n  }\n}\n\n...\n\n// Assume that tree is a deeply nested tree of TextModel objects\n\ntree.index(true);\n\nlet arrayOfModelsThatHaveHello = tree.get('hello');  In this example, the call to  index()  builds a new Trie internal to the root  tree  model. It indexes every single property that has been added with  index  set to true.  The index method has the following signature:  index(recurse = false, trieSearchOptions = {}, trieSearch = undefined)   recurse : whether to recurse into child models and their indexed properties.  trieSearchOptions : these options will be passed into the Trie search. See the  documentation  for details.  trieSearch : if you want to provide your own instance of the Trie, you may pass it in here. If none is passed, a new one is constructed automatically.   Indexing is not performed automatically, you must call  index()  yourself. Also please do not call  index()  more often than is necessary as building the indexing structure\nis time-intensive on large model trees.  Note: the  addIndexedPropery()  method can be used instead of  addProperty(name, {index:true}) .", 
            "title": "2.7 Indexing (Trie) and the index option for search"
        }, 
        {
            "location": "/docs/controller/", 
            "text": "Controller\n\n\n\n\nExtends \nRingaObject\n\n\n\n\nThe Ringa JS \nController\n serves the following functions:\n\n\n\n\nA container for \nModels\n\n\nListens to DOM nodes or \nBus\n objects for events\n\n\nCreates and coordinates asynchronous threads in response to events\n\n\n\n\nThe Ringa JS \nController\n is capable of handling any asynchronous operation in your application in a modularized and highly readable fashion.\n\n\n1. Construction\n\n\nA \nController\n can be constructed easily:\n\n\nimport {Controller} from 'react-ringa';\n\n\n\n1.1. Options\n\n\n2. Listening for Events\n\n\n3. Using Executors\n\n\nEvery Ringa JS \nController\n listens to a \nBus\n object for events by their String type:", 
            "title": "Controller *"
        }, 
        {
            "location": "/docs/controller/#controller", 
            "text": "Extends  RingaObject   The Ringa JS  Controller  serves the following functions:   A container for  Models  Listens to DOM nodes or  Bus  objects for events  Creates and coordinates asynchronous threads in response to events   The Ringa JS  Controller  is capable of handling any asynchronous operation in your application in a modularized and highly readable fashion.", 
            "title": "Controller"
        }, 
        {
            "location": "/docs/controller/#1-construction", 
            "text": "A  Controller  can be constructed easily:  import {Controller} from 'react-ringa';", 
            "title": "1. Construction"
        }, 
        {
            "location": "/docs/controller/#11-options", 
            "text": "", 
            "title": "1.1. Options"
        }, 
        {
            "location": "/docs/controller/#2-listening-for-events", 
            "text": "", 
            "title": "2. Listening for Events"
        }, 
        {
            "location": "/docs/controller/#3-using-executors", 
            "text": "Every Ringa JS  Controller  listens to a  Bus  object for events by their String type:", 
            "title": "3. Using Executors"
        }, 
        {
            "location": "/docs/executors/", 
            "text": "Executors\n\n\nUnder construction", 
            "title": "Executors *"
        }, 
        {
            "location": "/docs/executors/#executors", 
            "text": "Under construction", 
            "title": "Executors"
        }, 
        {
            "location": "/reactLibrary/introduction/", 
            "text": "Introduction\n\n\nThe Ringa React Library is a full-fledged library of React components to help you rapidly build your application.\n\n\nDemonstration\n\n\nUnder construction, more examples coming soon (over 20 components so far, just not all documented!):\n\n\n\n\nIndex\n\n\nCheckbox\n\n\nForm\n\n\nI18N\n\n\nList\n\n\nNumber Input\n\n\nRadio Button\n\n\nScroll Container\n\n\nTab Navigator\n\n\nText Input\n\n\nTheme\n\n\n\n\nLicense\n\n\nFor non-commercial use, the Ringa React Library is free. However, if you wish to use the library commercially, you must purchase a yearly license per top-level-domain.", 
            "title": "Introduction"
        }, 
        {
            "location": "/reactLibrary/introduction/#introduction", 
            "text": "The Ringa React Library is a full-fledged library of React components to help you rapidly build your application.", 
            "title": "Introduction"
        }, 
        {
            "location": "/reactLibrary/introduction/#demonstration", 
            "text": "Under construction, more examples coming soon (over 20 components so far, just not all documented!):   Index  Checkbox  Form  I18N  List  Number Input  Radio Button  Scroll Container  Tab Navigator  Text Input  Theme", 
            "title": "Demonstration"
        }, 
        {
            "location": "/reactLibrary/introduction/#license", 
            "text": "For non-commercial use, the Ringa React Library is free. However, if you wish to use the library commercially, you must purchase a yearly license per top-level-domain.", 
            "title": "License"
        }, 
        {
            "location": "/reactLibrary/examples/", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/reactLibrary/licensing/", 
            "text": "", 
            "title": "Licensing *"
        }, 
        {
            "location": "/reactLibrary/core/", 
            "text": "Core\n\n\nUnder construction", 
            "title": "Core *"
        }, 
        {
            "location": "/reactLibrary/core/#core", 
            "text": "Under construction", 
            "title": "Core"
        }, 
        {
            "location": "/reactLibrary/arrayCollection/", 
            "text": "", 
            "title": "ArrayCollection *"
        }, 
        {
            "location": "/reactLibrary/ringaComponent/", 
            "text": "", 
            "title": "RingaComponent *"
        }, 
        {
            "location": "/reactLibrary/container/", 
            "text": "", 
            "title": "Container *"
        }, 
        {
            "location": "/reactLibrary/overlays/", 
            "text": "Overlays\n\n\nUnder construction", 
            "title": "Overlays *"
        }, 
        {
            "location": "/reactLibrary/overlays/#overlays", 
            "text": "Under construction", 
            "title": "Overlays"
        }, 
        {
            "location": "/reactLibrary/modals/", 
            "text": "Modals\n\n\nUnder construction", 
            "title": "Modals *"
        }, 
        {
            "location": "/reactLibrary/modals/#modals", 
            "text": "Under construction", 
            "title": "Modals"
        }, 
        {
            "location": "/reactLibrary/dragDrop/", 
            "text": "Drag and Drop\n\n\nUnder construction", 
            "title": "Drag and Drop *"
        }, 
        {
            "location": "/reactLibrary/dragDrop/#drag-and-drop", 
            "text": "Under construction", 
            "title": "Drag and Drop"
        }, 
        {
            "location": "/reactLibrary/list/", 
            "text": "List\n\n\nUnder construction", 
            "title": "List *"
        }, 
        {
            "location": "/reactLibrary/list/#list", 
            "text": "Under construction", 
            "title": "List"
        }, 
        {
            "location": "/reactLibrary/list/", 
            "text": "List\n\n\nUnder construction", 
            "title": "TextInput *"
        }, 
        {
            "location": "/reactLibrary/list/#list", 
            "text": "Under construction", 
            "title": "List"
        }, 
        {
            "location": "/reactLibrary/list/", 
            "text": "List\n\n\nUnder construction", 
            "title": "NumberInput *"
        }, 
        {
            "location": "/reactLibrary/list/#list", 
            "text": "Under construction", 
            "title": "List"
        }, 
        {
            "location": "/reactLibrary/radioButton/", 
            "text": "", 
            "title": "RadioButton *"
        }, 
        {
            "location": "/reactLibrary/Checkbox/", 
            "text": "", 
            "title": "Checkbox *"
        }, 
        {
            "location": "/reactLibrary/Dropdown/", 
            "text": "Dropdown\n\n\nUnder construction", 
            "title": "Dropdown *"
        }, 
        {
            "location": "/reactLibrary/Dropdown/#dropdown", 
            "text": "Under construction", 
            "title": "Dropdown"
        }, 
        {
            "location": "/reactLibrary/tabNavigator/", 
            "text": "", 
            "title": "TabNavigator *"
        }, 
        {
            "location": "/links/", 
            "text": "Code\n\n\n\n\nRinga Github\n\n\nReact Ringa Github\n\n\nDemo Github\n\n\n\n\nTemplate\n\n\n\n\nRingaJS Application Template\n.\n\n\n\n\nDemo\n\n\n\n\nFull Demonstration\n\n\n\n\nVideos\n\n\n\n\nInitial Presentation\n\nSkip to about 10 minutes in.", 
            "title": "Links"
        }, 
        {
            "location": "/links/#code", 
            "text": "Ringa Github  React Ringa Github  Demo Github", 
            "title": "Code"
        }, 
        {
            "location": "/links/#template", 
            "text": "RingaJS Application Template .", 
            "title": "Template"
        }, 
        {
            "location": "/links/#demo", 
            "text": "Full Demonstration", 
            "title": "Demo"
        }, 
        {
            "location": "/links/#videos", 
            "text": "Initial Presentation \nSkip to about 10 minutes in.", 
            "title": "Videos"
        }
    ]
}