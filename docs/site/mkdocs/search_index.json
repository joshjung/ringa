{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to RingaJS\n\n\nWhat is it\n\n\nRingaJS is a single page application framework that includes:\n\n\n\n\nMVC / MVVM hybrid\n structure with little boilerplate\n\n\nState management\n with no singletons\n\n\nPerformance centered \nobserver pattern\n\n\nDependency injection\n\n\nAsynchronous toolset\n with branching, looping, and error handling\n\n\n\n\nIt is hard to explain what Ringa is in a single sentence because it just does so much. This was built in my spare time the last year as a way to shift all the most difficult\nconcepts to rapid application development into a core set of Classes to improve my own development speed. It was also designed as a way to organize large enterprise\napplications in a way that made it extremely easy to monitor large teams as they work in a growing codebase.\n\n\nRinga's philosophy can be summed up with a few mantras:\n\n\n\n\nShield new developers from concepts they do not need to know... yet\n\n\nLet seasoned developers configure or extend anything\n\n\nGive everyone easy to understand error messages and warnings\n\n\nNever sacrifice performance\n\n\nNo fancy string parsing for observers\n\n\nGive developers 100% control over their observables\n\n\n\n\nLatest Version\n\n\nTesting\n\n\nRinga currently has around 200 unit tests to ensure its core features are running smoothly.\n\n\nUnder Construction\n\n\nRingaJS is currently in Alpha version and has been so since Janary 2017, and while being used live, has not been battle-tested on a large scale quite yet. We would\nlove your input and your bug reports.\n\n\nRequirements\n\n\nRight now RingaJS is being developed for an ES6+ development environment and has been tested on:\n\n\n\n\nChrome\n\n\nFirefox\n\n\nSafari\n\n\nIE 11+\n\n\n\n\nInstallation\n\n\n\n\nnpm install --save-dev ringa\n - Install Ringa into", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-ringajs", 
            "text": "", 
            "title": "Welcome to RingaJS"
        }, 
        {
            "location": "/#what-is-it", 
            "text": "RingaJS is a single page application framework that includes:   MVC / MVVM hybrid  structure with little boilerplate  State management  with no singletons  Performance centered  observer pattern  Dependency injection  Asynchronous toolset  with branching, looping, and error handling   It is hard to explain what Ringa is in a single sentence because it just does so much. This was built in my spare time the last year as a way to shift all the most difficult\nconcepts to rapid application development into a core set of Classes to improve my own development speed. It was also designed as a way to organize large enterprise\napplications in a way that made it extremely easy to monitor large teams as they work in a growing codebase.  Ringa's philosophy can be summed up with a few mantras:   Shield new developers from concepts they do not need to know... yet  Let seasoned developers configure or extend anything  Give everyone easy to understand error messages and warnings  Never sacrifice performance  No fancy string parsing for observers  Give developers 100% control over their observables", 
            "title": "What is it"
        }, 
        {
            "location": "/#latest-version", 
            "text": "", 
            "title": "Latest Version"
        }, 
        {
            "location": "/#testing", 
            "text": "Ringa currently has around 200 unit tests to ensure its core features are running smoothly.", 
            "title": "Testing"
        }, 
        {
            "location": "/#under-construction", 
            "text": "RingaJS is currently in Alpha version and has been so since Janary 2017, and while being used live, has not been battle-tested on a large scale quite yet. We would\nlove your input and your bug reports.", 
            "title": "Under Construction"
        }, 
        {
            "location": "/#requirements", 
            "text": "Right now RingaJS is being developed for an ES6+ development environment and has been tested on:   Chrome  Firefox  Safari  IE 11+", 
            "title": "Requirements"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install --save-dev ringa  - Install Ringa into", 
            "title": "Installation"
        }, 
        {
            "location": "/whyRinga/", 
            "text": "When designing Ringa we asked the following questions:\n\n\n\n\nWhat is the development problem?\n\n\nWhat would be the most enjoyable code to write to solve it?\n\n\nIs this going to scale and not impact the \ncomputers performance\n?\n\n\nIs this going to scale and not impact the \nnext developers performance\n?\n\n\n\n\nWe went back to the drawing board and put on our computer scientist caps to solve each problem and answer each of the 4 Questions. As a result, to understand why Ringa is so powerful a basic understanding of trees, graphs, algorithms, and software design patterns like singletons, factories, decorators, and dependency injection is a huge plus.\n\n\nAdvantages\n\n\nRinga provides the following high-level architectural advantages:\n\n\n\n\nUses DOM event system\n\n\nControllers are attached to a DOM node so there are no God objects\n\n\nUse 'bubble' and 'capture' to communicate between controllers through the DOM\n\n\nIntercept events at a higher level in the DOM so that the root of your application always has complete control\n\n\nAll RingaEvents include information on the view that dispatched them, the line of code they were dispatched from, the controller that is handling them, the commands that are responding, and much, much more\n\n\nFollows the Best MVC principles\n\n\nControllers are designed to keep your view, API, control, and model separated\n\n\nAsynchronous Syntax\n\n\nWriting complicated trees of asynchronous and synchronous processes is simple\n\n\nReading someone else's complex tree of asynchronous tasks is straightforward\n\n\nExtending, intercepting, or injecting into an existing asynchronous process is easy, but never interferes with debugging so there are no surprises\n\n\nDebugging when something fails in a complex tree of asynchronous tasks is at your fingertips\n\n\n\n\nDeveloping with Ringa\n\n\nRinga is designed for enterprise-level applications and scales with your team to keep everyone happy. It is designed with the idea that you will eventually have a large application with a lot of library dependencies and also so that your code can be cordoned off into discrete sections so that there is less developer conflict during development.", 
            "title": "Why Ringa"
        }, 
        {
            "location": "/whyRinga/#advantages", 
            "text": "Ringa provides the following high-level architectural advantages:   Uses DOM event system  Controllers are attached to a DOM node so there are no God objects  Use 'bubble' and 'capture' to communicate between controllers through the DOM  Intercept events at a higher level in the DOM so that the root of your application always has complete control  All RingaEvents include information on the view that dispatched them, the line of code they were dispatched from, the controller that is handling them, the commands that are responding, and much, much more  Follows the Best MVC principles  Controllers are designed to keep your view, API, control, and model separated  Asynchronous Syntax  Writing complicated trees of asynchronous and synchronous processes is simple  Reading someone else's complex tree of asynchronous tasks is straightforward  Extending, intercepting, or injecting into an existing asynchronous process is easy, but never interferes with debugging so there are no surprises  Debugging when something fails in a complex tree of asynchronous tasks is at your fingertips", 
            "title": "Advantages"
        }, 
        {
            "location": "/whyRinga/#developing-with-ringa", 
            "text": "Ringa is designed for enterprise-level applications and scales with your team to keep everyone happy. It is designed with the idea that you will eventually have a large application with a lot of library dependencies and also so that your code can be cordoned off into discrete sections so that there is less developer conflict during development.", 
            "title": "Developing with Ringa"
        }, 
        {
            "location": "/model/", 
            "text": "Model\n\n\nThe Ringa Model class is a core part of the framework that is not necessary to use but provides a significant\namount of powerful functionality.\n\n\nThe Ringa Model class provides:\n\n\n\n\nProperty management\n\n\nProperty watching\n\n\nBuilt in tree structure (optional)\n\n\nCloning (recursive)\n\n\nSerialization / deserialization (recursive)\n\n\nTrie-based indexing for search (recursive)\n\n\n\n\nExample\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}\n\n\n\nIn this example, the \nUserModel\n is configured with three properties that by default:\n\n\n\n\nCan be watched for changes\n\n\nWill be included when serializing / deserializing\n\n\n\n\n1.1 Watching / Observing\n\n\nUsing the above Class \nUserModel\n, we could do the following:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';\n\n\n\nThe console will now output:\n\n\nA property has changed 'firstName': Saajan\n\n\n\n1.2 Model Property Defaults\n\n\nYou can specify default values for \nModel\n properties easily:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}\n\n\n\nAll properties in the \nModel\n default to \nundefined\n. In this case, we are saying the altitude should start, as it should, at \n0\n.\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.altitude);\n\n\n\nOutput:\n\n\n0\n\n\n\n1.3 Model Property Options (\npropertyOptions\n)\n\n\nThe third parameter to \naddProperty\n is an optional options \nObject\n:\n\n\nclass Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}\n\n\n\nAll property options can be accessed through the \npropertyOptions\n dictionary:\n\n\nlet airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);\n\n\n\nOutput:\n\n\nThis is the altitude of the airplane.\n\n\n\nBe careful! If you accidentally pass the property options as the second parameter to \naddProperty\n they will be treated as the default value.\n\n\nNote: the following propertyOptions are reserved and used by Ringa:\n\n\n\n\ndescriptor\n\n\nsetParentModel\n\n\nautowatch\n\n\ndoNotNotify\n\n\nclone\n\n\ntype\n\n\nserialize\n\n\nget\n\n\nset\n\n\n\n\n1.4 Custom Getters / Setters\n\n\nBy default, Ringa uses \nObject.defineProperty\n every time you call \naddProperty()\n to create a custom getter / setter on your model.\n\n\nHowever, you can override this quite easily:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =\n {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =\n {\n        return this._address;\n      }\n    });\n  }\n}\n\n\n\nNote: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!\n\n\n2. Notifications\n\n\nBy default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.\n\n\nuser.watch(signal =\n console.log);\n\nuser.firstName = 'Josh');\n\n\n\nOutput:\n\n\nfirstName\n\n\n\nBut if the property does not change in value, then no signal is dispatched:\n\n\n// Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';\n\n\n\n2.1. Custom Notifications\n\n\nOne cool feature of the Ringa \nModel\n is that you can notify your own custom signals:\n\n\nlet user = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');\n\n\n\n2.2. Turning off Notifications\n\n\nAnother cool feature of the Model is that you can turn off notifications to improve performance by using the property options:\n\n\nimport {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =\n {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');\n\n\n\nIn the above example, to increase performance we notify a special event when either the \nfirstName\n or \nlastName\n has changed.\n\n\n2.3 Aggregating Complex Properties\n\n\nA lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.\n\n\nUnfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:\n\n\n\n\nBindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.\n\n\nIncluding complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.\n\n\n\n\nMy goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.\n\n\nNothing in Ringa updates unless you explicitly tell it to.\n\n\nSee the next section (2.4) for an example of how to more complex operations triggered by a property change. \n\n\n2.4 Watching changes with \nonChange\n\n\nIf you want to do complex operations, you can do so like this:\n\n\nimport {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =\n {\n        this.notify('items');\n      }\n    });\n  }\n}\n\n\n\nNote: \nonChange\n only gets called if the value of the property \nfilter\n above actually changes to a new value.\n\n\nNow, when \nfilter\n changes, an \nitems\n signal will be dispatched:\n\n\nlet collection = new Collection();\n\ncollection.watch(signal =\n {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =\n value !== 2;\n\n\n\nOutput:\n\n\n1, 3\n\n\n\nThis notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.", 
            "title": "Model"
        }, 
        {
            "location": "/model/#model", 
            "text": "The Ringa Model class is a core part of the framework that is not necessary to use but provides a significant\namount of powerful functionality.  The Ringa Model class provides:   Property management  Property watching  Built in tree structure (optional)  Cloning (recursive)  Serialization / deserialization (recursive)  Trie-based indexing for search (recursive)", 
            "title": "Model"
        }, 
        {
            "location": "/model/#example", 
            "text": "import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName');\n    this.addProperty('lastName');\n    this.addProperty('email');\n  }\n}  In this example, the  UserModel  is configured with three properties that by default:   Can be watched for changes  Will be included when serializing / deserializing", 
            "title": "Example"
        }, 
        {
            "location": "/model/#11-watching-observing", 
            "text": "Using the above Class  UserModel , we could do the following:  let user = new UserModel();\n\nuser.watch(signal =  {\n  console.log(`A property has changed '${signal}': ${user[signal]}`);\n});\n\nuser.firstName = 'Saajan';  The console will now output:  A property has changed 'firstName': Saajan", 
            "title": "1.1 Watching / Observing"
        }, 
        {
            "location": "/model/#12-model-property-defaults", 
            "text": "You can specify default values for  Model  properties easily:  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0);\n  }\n}  All properties in the  Model  default to  undefined . In this case, we are saying the altitude should start, as it should, at  0 .  let airplane = new Airplane();\n\nconsole.log(airplane.altitude);  Output:  0", 
            "title": "1.2 Model Property Defaults"
        }, 
        {
            "location": "/model/#13-model-property-options-propertyoptions", 
            "text": "The third parameter to  addProperty  is an optional options  Object :  class Airplane extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('altitude', 0, {\n      description: 'This is the altitude of the airplane.'\n    });\n  }\n}  All property options can be accessed through the  propertyOptions  dictionary:  let airplane = new Airplane();\n\nconsole.log(airplane.propertyOptions.altitude.description);  Output:  This is the altitude of the airplane.  Be careful! If you accidentally pass the property options as the second parameter to  addProperty  they will be treated as the default value.  Note: the following propertyOptions are reserved and used by Ringa:   descriptor  setParentModel  autowatch  doNotNotify  clone  type  serialize  get  set", 
            "title": "1.3 Model Property Options (propertyOptions)"
        }, 
        {
            "location": "/model/#14-custom-getters-setters", 
            "text": "By default, Ringa uses  Object.defineProperty  every time you call  addProperty()  to create a custom getter / setter on your model.  However, you can override this quite easily:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('address', undefined, {\n      set: value =  {\n        this._address = value ? value.toUpperCase();\n        this.notify('address');\n      },\n      get: () =  {\n        return this._address;\n      }\n    });\n  }\n}  Note: if you override the internal setter you will not get any of the built in notification features unless you call them yourself!", 
            "title": "1.4 Custom Getters / Setters"
        }, 
        {
            "location": "/model/#2-notifications", 
            "text": "By default, Ringa Models automatically dispatch (notify) a new signal that matches the property name when that property changes in value.  user.watch(signal =  console.log);\n\nuser.firstName = 'Josh');  Output:  firstName  But if the property does not change in value, then no signal is dispatched:  // Signal 'firstName' is dispatched first time!\nuser.firstName = 'Saajan';\n\n// Signal 'firstName' is NOT dispatched, because property has not changed\nuser.firstName = 'Saajan';", 
            "title": "2. Notifications"
        }, 
        {
            "location": "/model/#21-custom-notifications", 
            "text": "One cool feature of the Ringa  Model  is that you can notify your own custom signals:  let user = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'update') {\n    doSomeHugeTask();\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\nuser.email = 'saajan@somewhere.com';\n\nuser.notify('update');", 
            "title": "2.1. Custom Notifications"
        }, 
        {
            "location": "/model/#22-turning-off-notifications", 
            "text": "Another cool feature of the Model is that you can turn off notifications to improve performance by using the property options:  import {Model} from 'ringa';\n\nclass UserModel extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('firstName', {doNotNotify: true});\n    this.addProperty('lastName', {doNotNotify: true});\n  }\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\n...\n\nuser = new UserModel();\n\nuser.watch(signal =  {\n  if (signal === 'change') {\n    console.log('The name has changed! ${user.fullName}');\n  }\n});\n\nuser.firstName = 'Saajan';\nuser.lastName = 'Smith';\n\nuser.notify('change');  In the above example, to increase performance we notify a special event when either the  firstName  or  lastName  has changed.", 
            "title": "2.2. Turning off Notifications"
        }, 
        {
            "location": "/model/#23-aggregating-complex-properties", 
            "text": "A lot of observable frameworks like MobX and Angular attempt to deduce what you want updated by reading complex strings that combine filtering, sorting, etc. Many of\nthem do this by parsing the string, breaking it down into variable names, and then watching all the variables for updates.  Unfortunately, at the beginning of a smaller project this is really helpful but it causes several problems especially as a project scales:   Bindings can begin to cause unpredicable performance drops when updating a single variable causes a huge tree of observables to be triggered.  Including complex math or array reduce / map / filters inside of strings limits your IDEs ability to parse some of your most important code.   My goal with Ringa was to avoid these two problems as much as possible. As a result, the Models in Ringa give most of the power of these updates to you, the developer.  Nothing in Ringa updates unless you explicitly tell it to.  See the next section (2.4) for an example of how to more complex operations triggered by a property change.", 
            "title": "2.3 Aggregating Complex Properties"
        }, 
        {
            "location": "/model/#24-watching-changes-with-onchange", 
            "text": "If you want to do complex operations, you can do so like this:  import {Model} from 'ringa';\n\nclass Collection extends Model {\n  constructor(name, values) {\n    super(name, values);\n\n    this.addProperty('data');  // Input array (immutable)\n    this.addProperty('items', {\n      get: () {\n        return this.data ? this.data.filter(this.filter) : [];\n      }\n    }); // Output array (determined by filter)\n\n    this.addProperty('filter', {\n      onChange: (oldValue, newValue) =  {\n        this.notify('items');\n      }\n    });\n  }\n}  Note:  onChange  only gets called if the value of the property  filter  above actually changes to a new value.  Now, when  filter  changes, an  items  signal will be dispatched:  let collection = new Collection();\n\ncollection.watch(signal =  {\n  if (signal === 'items') {\n    console.log(\"Items are now: ${collection.items.join(',')}\");\n  }\n});\n\ncollection.data = [1, 2, 3];\ncollection.filter = value =  value !== 2;  Output:  1, 3  This notification feature of models is the foundation of the high performance of Ringa because nothing happens that you do not \nexplicitly tell Ringa to do, so you can avoid all the performance bottlenecks from the beginning that tend to bog down enterprise software.", 
            "title": "2.4 Watching changes with onChange"
        }
    ]
}